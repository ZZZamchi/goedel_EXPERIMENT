{"name": "surjection_of_formally_unramified", "problem_id": "63_surjection_of_formally_unramified", "informal_prefix": "", "formal_statement": "theorem surjection_of_formally_unramified (R S : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Algebra.FormallyUnramified R S] :\n    ‚àÉ (S' : Type) (_ : CommRing S') (_ : Algebra R S') (f : S' ‚Üí‚Çê[R] S), (RingHom.ker f) ^ 2 = 0 ‚àß UniversalProperty.liftOfSqZeroIdeal f := by\n  sorry", "lean4_code": "import Mathlib\ntheorem surjection_of_formally_unramified (R S : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Algebra.FormallyUnramified R S] :\n    ‚àÉ (S' : Type) (_ : CommRing S') (_ : Algebra R S') (f : S' ‚Üí‚Çê[R] S), (RingHom.ker f) ^ 2 = 0 ‚àß UniversalProperty.liftOfSqZeroIdeal f := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "associatedPrimes_hom_eq_support_inter_associatedPrimes", "problem_id": "36_associatedPrimes_hom_eq_support_inter_associatedPrimes", "informal_prefix": "", "formal_statement": "theorem associatedPrimes_hom_eq_support_inter_associatedPrimes (R : Type) [CommRing R]\n    [IsNoetherianRing R] (M N : Type) [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]\n    [Module.Finite R M] [Module.Finite R N] : associatedPrimes R (M ‚Üí‚Çó[R] N) =\n    {p | p ‚àà associatedPrimes R N ‚àß Module.annihilator R M ‚â§ p} := by\n  sorry", "lean4_code": "import Mathlib\ntheorem associatedPrimes_hom_eq_support_inter_associatedPrimes (R : Type) [CommRing R]\n    [IsNoetherianRing R] (M N : Type) [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]\n    [Module.Finite R M] [Module.Finite R N] : associatedPrimes R (M ‚Üí‚Çó[R] N) =\n    {p | p ‚àà associatedPrimes R N ‚àß Module.annihilator R M ‚â§ p} := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "sq_eq_self_of_not_unit", "problem_id": "13_sq_eq_self_of_not_unit", "informal_prefix": "/--\nLet $(R,+,\\cdot)$ be a (not necessarily commutative) ring.\nIf we know that $R$ is not a field and $x^2=x$ for any $x\\in R,$\nwhere $x$ is not invertible. Prove that $x^2=x$ for any $x.$\n-/", "formal_statement": "import Mathlib\n\n/--\nLet $(R,+,\\cdot)$ be a (not necessarily commutative) ring.\nIf we know that $R$ is not a field and $x^2=x$ for any $x\\in R,$\nwhere $x$ is not invertible. Prove that $x^2=x$ for any $x.$\n-/\ntheorem sq_eq_self_of_not_unit {R : Type} [Ring R] (h : ¬¨ IsField R)\n    (h2 : ‚àÄ x : R, ¬¨ IsUnit x ‚Üí x^2 = x) (x : R) : x^2 = x := by\n  sorry", "lean4_code": "import Mathlib\n\n/--\nLet $(R,+,\\cdot)$ be a (not necessarily commutative) ring.\nIf we know that $R$ is not a field and $x^2=x$ for any $x\\in R,$\nwhere $x$ is not invertible. Prove that $x^2=x$ for any $x.$\n-/\ntheorem sq_eq_self_of_not_unit {R : Type} [Ring R] (h : ¬¨ IsField R)\n    (h2 : ‚àÄ x : R, ¬¨ IsUnit x ‚Üí x^2 = x) (x : R) : x^2 = x := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "moduleDepth", "problem_id": "71_moduleDepth", "informal_prefix": "/--\nLet \\( G \\) be a finite group acting as automorphisms of an algebra \\( R \\) over a field of characteristic \\( 0 \\).\nShow that if \\( R \\) is Cohen-Macaulay, then the ring of invariants \\( R^G \\) is Cohen-Macaulay.\n-/", "formal_statement": "def moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\n/--\nLet \\( G \\) be a finite group acting as automorphisms of an algebra \\( R \\) over a field of characteristic \\( 0 \\).\nShow that if \\( R \\) is Cohen-Macaulay, then the ring of invariants \\( R^G \\) is Cohen-Macaulay.\n-/", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\n\n/--\nLet \\( G \\) be a finite group acting as automorphisms of an algebra \\( R \\) over a field of characteristic \\( 0 \\).\nShow that if \\( R \\) is Cohen-Macaulay, then the ring of invariants \\( R^G \\) is Cohen-Macaulay.\n-/\ndef moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\n/--\nLet \\( G \\) be a finite group acting as automorphisms of an algebra \\( R \\) over a field of characteristic \\( 0 \\).\nShow that if \\( R \\) is Cohen-Macaulay, then the ring of invariants \\( R^G \\) is Cohen-Macaulay.\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "pic_three_lines", "problem_id": "91_pic_three_lines", "informal_prefix": "/-- The Picard group of a commutative ring R consists of the invertible R-modules,\n  up to isomorphism. -/", "formal_statement": "import Mathlib\n\nopen CategoryTheory MvPolynomial\n\n/-- The Picard group of a commutative ring R consists of the invertible R-modules,\n  up to isomorphism. -/\nabbrev CommRing.Pic (R : Type) [CommRing R] : Type 1 := (Skeleton <| ModuleCat.{0} R)À£\n\n/--\nLet $ k $ be a field, $ A := k[x, y]/(xy(x + y - 1)) $, then $ \\mathrm{Pic}\\ A \\cong k^{\\times} $.\n-/\ntheorem pic_three_lines {k : Type} [Field k] : Nonempty <|\n    CommRing.Pic (MvPolynomial (Fin 2) k ‚ß∏ Ideal.span ({(X 0) * (X 1) * (X 0 + X 1 - 1)} :\n    Set (MvPolynomial (Fin 2) k))) ‚âÉ* kÀ£ := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory MvPolynomial\n\n/-- The Picard group of a commutative ring R consists of the invertible R-modules,\n  up to isomorphism. -/\nabbrev CommRing.Pic (R : Type) [CommRing R] : Type 1 := (Skeleton <| ModuleCat.{0} R)À£\n\n/--\nLet $ k $ be a field, $ A := k[x, y]/(xy(x + y - 1)) $, then $ \\mathrm{Pic}\\ A \\cong k^{\\times} $.\n-/\ntheorem pic_three_lines {k : Type} [Field k] : Nonempty <|\n    CommRing.Pic (MvPolynomial (Fin 2) k ‚ß∏ Ideal.span ({(X 0) * (X 1) * (X 0 + X 1 - 1)} :\n    Set (MvPolynomial (Fin 2) k))) ‚âÉ* kÀ£ := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isPrincipalIdealRing_of_quadratic_integer_19", "problem_id": "12_isPrincipalIdealRing_of_quadratic_integer_19", "informal_prefix": "", "formal_statement": "theorem isPrincipalIdealRing_of_quadratic_integer_19 :\n    IsPrincipalIdealRing (Algebra.adjoin ‚Ñ§ {(1 + (Real.sqrt 19) * Complex.I) / 2}) ‚àß IsDomain (Algebra.adjoin ‚Ñ§ {(1 + (Real.sqrt 19) * Complex.I) / 2}) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isPrincipalIdealRing_of_quadratic_integer_19 :\n    IsPrincipalIdealRing (Algebra.adjoin ‚Ñ§ {(1 + (Real.sqrt 19) * Complex.I) / 2}) ‚àß IsDomain (Algebra.adjoin ‚Ñ§ {(1 + (Real.sqrt 19) * Complex.I) / 2}) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_point_not_in_zero_set", "problem_id": "97_exists_point_not_in_zero_set", "informal_prefix": "/--\nIf $k$ is a field of characteristic zero, $n \\in \\mathbb{N}$, $n \\ne 0$,\nand $\\phi \\colon k[x_1, \\dots, x_n] \\to k[x_1, \\dots, x_n]$ is given by $(x_1, \\dots, x_n) \\mapsto (f_1(x_1), \\dots, f_n(x_n))$,\nwhere $f_i(x_i) \\in k[x_i]$ having degree at least two, then there is a point $a \\in k^n$\nsuch that for any non-zero polyminal $p \\in k[x_1, \\dots, x_n]$,\nthere exists $m \\in \\mathbb{N}$ such that $p(\\phi^m(a)) \\ne 0$. -/", "formal_statement": "import Mathlib\n\nopen scoped Polynomial\n\n/--\nIf $k$ is a field of characteristic zero, $n \\in \\mathbb{N}$, $n \\ne 0$,\nand $\\phi \\colon k[x_1, \\dots, x_n] \\to k[x_1, \\dots, x_n]$ is given by $(x_1, \\dots, x_n) \\mapsto (f_1(x_1), \\dots, f_n(x_n))$,\nwhere $f_i(x_i) \\in k[x_i]$ having degree at least two, then there is a point $a \\in k^n$\nsuch that for any non-zero polyminal $p \\in k[x_1, \\dots, x_n]$,\nthere exists $m \\in \\mathbb{N}$ such that $p(\\phi^m(a)) \\ne 0$. -/\ntheorem exists_point_not_in_zero_set {œÑ k : Type} [Finite œÑ] [Nonempty œÑ] [Field k] [CharZero k]\n    {f : œÑ ‚Üí k[X]} (hfd : ‚àÄ i : œÑ, (f i).natDegree ‚â• 2): ‚àÉ a : œÑ ‚Üí k,\n    ‚àÄ p : MvPolynomial œÑ k, p ‚â† 0 ‚Üí\n    ‚àÉ m : ‚Ñï, (((MvPolynomial.aeval (fun i ‚Ü¶ (f i).toMvPolynomial i)) ^ m) p).aeval a ‚â† 0 := by\n  sorry", "lean4_code": "import Mathlib\n\nopen scoped Polynomial\n\n/--\nIf $k$ is a field of characteristic zero, $n \\in \\mathbb{N}$, $n \\ne 0$,\nand $\\phi \\colon k[x_1, \\dots, x_n] \\to k[x_1, \\dots, x_n]$ is given by $(x_1, \\dots, x_n) \\mapsto (f_1(x_1), \\dots, f_n(x_n))$,\nwhere $f_i(x_i) \\in k[x_i]$ having degree at least two, then there is a point $a \\in k^n$\nsuch that for any non-zero polyminal $p \\in k[x_1, \\dots, x_n]$,\nthere exists $m \\in \\mathbb{N}$ such that $p(\\phi^m(a)) \\ne 0$. -/\ntheorem exists_point_not_in_zero_set {œÑ k : Type} [Finite œÑ] [Nonempty œÑ] [Field k] [CharZero k]\n    {f : œÑ ‚Üí k[X]} (hfd : ‚àÄ i : œÑ, (f i).natDegree ‚â• 2): ‚àÉ a : œÑ ‚Üí k,\n    ‚àÄ p : MvPolynomial œÑ k, p ‚â† 0 ‚Üí\n    ‚àÉ m : ‚Ñï, (((MvPolynomial.aeval (fun i ‚Ü¶ (f i).toMvPolynomial i)) ^ m) p).aeval a ‚â† 0 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "principal_ideal_idempotent_iff_fg_ideal_is_direct_summand", "problem_id": "49_principal_ideal_idempotent_iff_fg_ideal_is_direct_summand", "informal_prefix": "", "formal_statement": "theorem principal_ideal_idempotent_iff_fg_ideal_is_direct_summand (A : Type) [CommRing A] :\n    (‚àÄ I : Ideal A, I.IsPrincipal ‚Üí I ^ 2 = I) ‚Üî\n    (‚àÄ I : Ideal A, I.FG ‚Üí (‚àÉ J : Ideal A, I ‚äî J = ‚ä§ ‚àß I ‚äì J = ‚ä• )) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem principal_ideal_idempotent_iff_fg_ideal_is_direct_summand (A : Type) [CommRing A] :\n    (‚àÄ I : Ideal A, I.IsPrincipal ‚Üí I ^ 2 = I) ‚Üî\n    (‚àÄ I : Ideal A, I.FG ‚Üí (‚àÉ J : Ideal A, I ‚äî J = ‚ä§ ‚àß I ‚äì J = ‚ä• )) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsRegularLocalRing", "problem_id": "43_IsRegularLocalRing", "informal_prefix": "/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/", "formal_statement": "import Mathlib\n\nopen IsLocalRing\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/--\nLet $A$ be a reduced Noetherian local ring, $\\mathrm{Char}\\ A = p$.\nShow that the absolute Frobenius $F_A\\colon A\\to A, a\\mapsto a^p$ is flat if and only if $A$ is regular.-/\ntheorem IsRegularLocalRing.frobenius_flat {A : Type} [CommRing A] [IsNoetherianRing A]\n    [IsLocalRing A] [IsReduced A] (p : ‚Ñï) [Fact p.Prime] [CharP A p] :\n    (frobenius A p).Flat ‚Üî IsRegularLocalRing A := by\n  sorry", "lean4_code": "import Mathlib\n\nopen IsLocalRing\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/--\nLet $A$ be a reduced Noetherian local ring, $\\mathrm{Char}\\ A = p$.\nShow that the absolute Frobenius $F_A\\colon A\\to A, a\\mapsto a^p$ is flat if and only if $A$ is regular.-/\ntheorem IsRegularLocalRing.frobenius_flat {A : Type} [CommRing A] [IsNoetherianRing A]\n    [IsLocalRing A] [IsReduced A] (p : ‚Ñï) [Fact p.Prime] [CharP A p] :\n    (frobenius A p).Flat ‚Üî IsRegularLocalRing A := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "Polynomial", "problem_id": "65_Polynomial", "informal_prefix": "/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/", "formal_statement": "import Mathlib\n\nopen IsLocalRing ModuleCat CategoryTheory Polynomial\n\ninstance (R : Type) [CommRing R] : CategoryTheory.HasExt.{0} (ModuleCat.{0} R) :=\n  CategoryTheory.hasExt_of_enoughProjectives.{0} (ModuleCat.{0} R)\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\n\n/--\nIf \\( A \\) is a Neotherian Gorenstein ring, then so is the polynomial ring \\( A[X] \\).\n-/\ntheorem Polynomial.isGorensteinRing {R : Type} [CommRing R] [IsGorensteinRing R] :\n    IsGorensteinRing R[X] := by\n  sorry", "lean4_code": "import Mathlib\n\nopen IsLocalRing ModuleCat CategoryTheory Polynomial\n\ninstance (R : Type) [CommRing R] : CategoryTheory.HasExt.{0} (ModuleCat.{0} R) :=\n  CategoryTheory.hasExt_of_enoughProjectives.{0} (ModuleCat.{0} R)\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\n\n/--\nIf \\( A \\) is a Neotherian Gorenstein ring, then so is the polynomial ring \\( A[X] \\).\n-/\ntheorem Polynomial.isGorensteinRing {R : Type} [CommRing R] [IsGorensteinRing R] :\n    IsGorensteinRing R[X] := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_eq_ofList_and_isRegular_of_perm", "problem_id": "66_exists_eq_ofList_and_isRegular_of_perm", "informal_prefix": "/-- Show that if an ideal $I$ in a Noetherian ring $R$ can be generated by a regular sequence,\nthen it can be generated by a set of elements that is a regular sequence in any order. -/", "formal_statement": "import Mathlib\n\nopen RingTheory\n\n/-- Show that if an ideal $I$ in a Noetherian ring $R$ can be generated by a regular sequence,\nthen it can be generated by a set of elements that is a regular sequence in any order. -/\ntheorem exists_eq_ofList_and_isRegular_of_perm {R : Type} [CommRing R] [IsNoetherianRing R] (I : Ideal R) (rs : List R)\n    (gen : I = Ideal.ofList rs) (h‚ÇÇ : Sequence.IsRegular R rs) : ‚àÉ rs' : List R,\n    I = Ideal.ofList rs' ‚àß (‚àÄ l : List R, (l.Perm rs') ‚Üí Sequence.IsRegular R l) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen RingTheory\n\n/-- Show that if an ideal $I$ in a Noetherian ring $R$ can be generated by a regular sequence,\nthen it can be generated by a set of elements that is a regular sequence in any order. -/\ntheorem exists_eq_ofList_and_isRegular_of_perm {R : Type} [CommRing R] [IsNoetherianRing R] (I : Ideal R) (rs : List R)\n    (gen : I = Ideal.ofList rs) (h‚ÇÇ : Sequence.IsRegular R rs) : ‚àÉ rs' : List R,\n    I = Ideal.ofList rs' ‚àß (‚àÄ l : List R, (l.Perm rs') ‚Üí Sequence.IsRegular R l) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "moduleDepth", "problem_id": "75_moduleDepth", "informal_prefix": "/--\nLet $A$ be a graded Noetherian ring, with $A_0$ a field and $A$ generated by $A_1$.\nShow that $A$ is Cohen-Macaulay if and only if for all homogeneously prime $\\mathfrak{p}$,\n$(A_{\\mathfrak{p}})_0$ is Cohen-Macaulay.\n-/", "formal_statement": "def moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\n/--\nLet $A$ be a graded Noetherian ring, with $A_0$ a field and $A$ generated by $A_1$.\nShow that $A$ is Cohen-Macaulay if and only if for all homogeneously prime $\\mathfrak{p}$,\n$(A_{\\mathfrak{p}})_0$ is Cohen-Macaulay.\n-/", "lean4_code": "import Mathlib\nopen IsLocalRing ModuleCat CategoryTheory\n\n/--\nLet $A$ be a graded Noetherian ring, with $A_0$ a field and $A$ generated by $A_1$.\nShow that $A$ is Cohen-Macaulay if and only if for all homogeneously prime $\\mathfrak{p}$,\n$(A_{\\mathfrak{p}})_0$ is Cohen-Macaulay.\n-/\ndef moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\n/--\nLet $A$ be a graded Noetherian ring, with $A_0$ a field and $A$ generated by $A_1$.\nShow that $A$ is Cohen-Macaulay if and only if for all homogeneously prime $\\mathfrak{p}$,\n$(A_{\\mathfrak{p}})_0$ is Cohen-Macaulay.\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "subring_iso_mvPowerSeries_over_DVR", "problem_id": "82_subring_iso_mvPowerSeries_over_DVR", "informal_prefix": "", "formal_statement": "theorem subring_iso_mvPowerSeries_over_DVR (d : ‚Ñï) (A : Type) [CommRing A] [IsLocalRing A]\n    [IsNoetherianRing A] [IsAdicComplete (maximalIdeal A) A] (dim : ringKrullDim A = d)\n    {p : ‚Ñï} (hp : p.Prime) [CharZero A] [CharP (ResidueField A) p]\n    (ht : (Ideal.span {(p : A)}).height = 1) :\n    ‚àÉ B : Subring A, Module.Finite B A ‚àß\n    ‚àÉ (C : Type) (_ : CommRing C) (_ : IsDomain C), IsDiscreteValuationRing C ‚àß\n    Nonempty (B ‚âÉ+* MvPowerSeries (Fin (d - 1)) C) := by\n  sorry", "lean4_code": "import Mathlib\nopen IsLocalRing\n\ntheorem subring_iso_mvPowerSeries_over_DVR (d : ‚Ñï) (A : Type) [CommRing A] [IsLocalRing A]\n    [IsNoetherianRing A] [IsAdicComplete (maximalIdeal A) A] (dim : ringKrullDim A = d)\n    {p : ‚Ñï} (hp : p.Prime) [CharZero A] [CharP (ResidueField A) p]\n    (ht : (Ideal.span {(p : A)}).height = 1) :\n    ‚àÉ B : Subring A, Module.Finite B A ‚àß\n    ‚àÉ (C : Type) (_ : CommRing C) (_ : IsDomain C), IsDiscreteValuationRing C ‚àß\n    Nonempty (B ‚âÉ+* MvPowerSeries (Fin (d - 1)) C) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "nonEmpty_ringEquiv_of_sub_in_cube", "problem_id": "42_nonEmpty_ringEquiv_of_sub_in_cube", "informal_prefix": "", "formal_statement": "theorem nonEmpty_ringEquiv_of_sub_in_cube (k : Type) [Field k]\n    (g : MvPowerSeries (Fin 2) k) (hg : g - .X 0 * .X 1 ‚àà (Ideal.span {MvPowerSeries.X 0, .X 1}) ^ 3) :\n    Nonempty (((MvPowerSeries (Fin 2) k) ‚ß∏ Ideal.span {(.X 0 * .X 1 : (MvPowerSeries (Fin 2) k))}) ‚âÉ+*\n    ((MvPowerSeries (Fin 2) k) ‚ß∏ Ideal.span {g})) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem nonEmpty_ringEquiv_of_sub_in_cube (k : Type) [Field k]\n    (g : MvPowerSeries (Fin 2) k) (hg : g - .X 0 * .X 1 ‚àà (Ideal.span {MvPowerSeries.X 0, .X 1}) ^ 3) :\n    Nonempty (((MvPowerSeries (Fin 2) k) ‚ß∏ Ideal.span {(.X 0 * .X 1 : (MvPowerSeries (Fin 2) k))}) ‚âÉ+*\n    ((MvPowerSeries (Fin 2) k) ‚ß∏ Ideal.span {g})) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "infinite_conj_of_ne_1_absoluteGaloisGroup", "problem_id": "28_infinite_conj_of_ne_1_absoluteGaloisGroup", "informal_prefix": "", "formal_statement": "theorem infinite_conj_of_ne_1_absoluteGaloisGroup (K : Type)\n    [Field K] [Algebra ‚Ñö K] [Module.Finite ‚Ñö K] (g : Field.absoluteGaloisGroup K) (h : g ‚â† 1) :\n    {g' : Field.absoluteGaloisGroup K | IsConj g g'}.Infinite := by\n  sorry", "lean4_code": "import Mathlib\ntheorem infinite_conj_of_ne_1_absoluteGaloisGroup (K : Type)\n    [Field K] [Algebra ‚Ñö K] [Module.Finite ‚Ñö K] (g : Field.absoluteGaloisGroup K) (h : g ‚â† 1) :\n    {g' : Field.absoluteGaloisGroup K | IsConj g g'}.Infinite := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "moduleDepth", "problem_id": "73_moduleDepth", "informal_prefix": "/--\nIf $I$ is an homogeneous ideal of $k[x_0, \\dots, x_n]$, \\( R = k[x_0, \\dots, x_n]/I \\),\nthen \\( R \\) is Cohen-Macaulay if and only if \\( R_P \\) is Cohen-Macaulay, where \\( P = (x_0, \\dots, x_n) \\).\n-/", "formal_statement": "def moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\nattribute [local instance] MvPolynomial.gradedAlgebra\n\n/--\nIf $I$ is an homogeneous ideal of $k[x_0, \\dots, x_n]$, \\( R = k[x_0, \\dots, x_n]/I \\),\nthen \\( R \\) is Cohen-Macaulay if and only if \\( R_P \\) is Cohen-Macaulay, where \\( P = (x_0, \\dots, x_n) \\).\n-/", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\n\n/--\nIf $I$ is an homogeneous ideal of $k[x_0, \\dots, x_n]$, \\( R = k[x_0, \\dots, x_n]/I \\),\nthen \\( R \\) is Cohen-Macaulay if and only if \\( R_P \\) is Cohen-Macaulay, where \\( P = (x_0, \\dots, x_n) \\).\n-/\ndef moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\nattribute [local instance] MvPolynomial.gradedAlgebra\n\n/--\nIf $I$ is an homogeneous ideal of $k[x_0, \\dots, x_n]$, \\( R = k[x_0, \\dots, x_n]/I \\),\nthen \\( R \\) is Cohen-Macaulay if and only if \\( R_P \\) is Cohen-Macaulay, where \\( P = (x_0, \\dots, x_n) \\).\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "mvPolynomial_quotient_isCohenMacaulayRing_iff", "problem_id": "73_mvPolynomial_quotient_isCohenMacaulayRing_iff", "informal_prefix": "", "formal_statement": "theorem mvPolynomial_quotient_isCohenMacaulayRing_iff (k : Type) [Field k] (n : ‚Ñï)\n    (R : Type) [CommRing R] (f : (MvPolynomial (Fin n) k) ‚Üí+* R) (surj : Function.Surjective f)\n    (homo : (RingHom.ker f).IsHomogeneous (MvPolynomial.homogeneousSubmodule (Fin n) k))\n    (le : RingHom.ker f ‚â§ RingHom.ker MvPolynomial.constantCoeff) :\n    IsCohenMacaulayRing R ‚Üî\n    IsCohenMacaulayRing (Localization.AtPrime ((RingHom.ker MvPolynomial.constantCoeff).map f)\n      (hp := Ideal.map_isPrime_of_surjective surj le (H := RingHom.ker_isPrime _))) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\n\ntheorem mvPolynomial_quotient_isCohenMacaulayRing_iff (k : Type) [Field k] (n : ‚Ñï)\n    (R : Type) [CommRing R] (f : (MvPolynomial (Fin n) k) ‚Üí+* R) (surj : Function.Surjective f)\n    (homo : (RingHom.ker f).IsHomogeneous (MvPolynomial.homogeneousSubmodule (Fin n) k))\n    (le : RingHom.ker f ‚â§ RingHom.ker MvPolynomial.constantCoeff) :\n    IsCohenMacaulayRing R ‚Üî\n    IsCohenMacaulayRing (Localization.AtPrime ((RingHom.ker MvPolynomial.constantCoeff).map f)\n      (hp := Ideal.map_isPrime_of_surjective surj le (H := RingHom.ker_isPrime _))) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "localization_jacobson_of_one_lt_ringKrullDim", "problem_id": "68_localization_jacobson_of_one_lt_ringKrullDim", "informal_prefix": "", "formal_statement": "theorem localization_jacobson_of_one_lt_ringKrullDim (R : Type) [CommRing R] [IsLocalRing R]\n    [IsNoetherianRing R] (f : R) (hf : f ‚àà IsLocalRing.maximalIdeal R) (ne0 : ¬¨ IsNilpotent f) :\n    IsJacobsonRing (Localization.Away f) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem localization_jacobson_of_one_lt_ringKrullDim (R : Type) [CommRing R] [IsLocalRing R]\n    [IsNoetherianRing R] (f : R) (hf : f ‚àà IsLocalRing.maximalIdeal R) (ne0 : ¬¨ IsNilpotent f) :\n    IsJacobsonRing (Localization.Away f) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "generate_unit_ideal_of_quotient", "problem_id": "52_generate_unit_ideal_of_quotient", "informal_prefix": "", "formal_statement": "theorem generate_unit_ideal_of_quotient (R : Type) [CommRing R] (m : Ideal R)\n    (h_le_jac : m ‚â§ Ring.jacobson R) (G‚ÇÅ G‚ÇÇ : Polynomial R) (h_monic : G‚ÇÅ.Monic)\n    (h_gen : Ideal.span {G‚ÇÅ.map (Ideal.Quotient.mk m), G‚ÇÇ.map (Ideal.Quotient.mk m)} = ‚ä§) :\n    Ideal.span {G‚ÇÅ, G‚ÇÇ} = ‚ä§ := by\n  sorry", "lean4_code": "import Mathlib\ntheorem generate_unit_ideal_of_quotient (R : Type) [CommRing R] (m : Ideal R)\n    (h_le_jac : m ‚â§ Ring.jacobson R) (G‚ÇÅ G‚ÇÇ : Polynomial R) (h_monic : G‚ÇÅ.Monic)\n    (h_gen : Ideal.span {G‚ÇÅ.map (Ideal.Quotient.mk m), G‚ÇÇ.map (Ideal.Quotient.mk m)} = ‚ä§) :\n    Ideal.span {G‚ÇÅ, G‚ÇÇ} = ‚ä§ := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isPrincipalIdealRing_quot_X_pow_two_plus_Y_pow_two_plus_one", "problem_id": "10_isPrincipalIdealRing_quot_X_pow_two_plus_Y_pow_two_plus_one", "informal_prefix": "", "formal_statement": "theorem isPrincipalIdealRing_quot_X_pow_two_plus_Y_pow_two_plus_one :\n    IsPrincipalIdealRing ((MvPolynomial (Fin 2) ‚Ñù) ‚ß∏\n    Ideal.span {(.X 0 ^ 2 + .X 1 ^ 2 + .C 1 : (MvPolynomial (Fin 2) ‚Ñù))}) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isPrincipalIdealRing_quot_X_pow_two_plus_Y_pow_two_plus_one :\n    IsPrincipalIdealRing ((MvPolynomial (Fin 2) ‚Ñù) ‚ß∏\n    Ideal.span {(.X 0 ^ 2 + .X 1 ^ 2 + .C 1 : (MvPolynomial (Fin 2) ‚Ñù))}) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "free_of_rank_iff", "problem_id": "40_free_of_rank_iff", "informal_prefix": "", "formal_statement": "theorem free_of_rank_iff (R : Type) [CommRing R] [IsLocalRing R] [IsReduced R]\n    (h : (minimalPrimes R).Finite) (r : ‚Ñï) (M : Type) [AddCommGroup M] [Module R M] [Module.Finite R M] :\n    Module.Free R M ‚àß Module.rank R M = r ‚Üî\n    (Module.rank (IsLocalRing.ResidueField R) ((IsLocalRing.ResidueField R) ‚äó[R] M) = r ‚àß\n    ‚àÄ p ‚àà minimalPrimes R,\n    Module.rank (FractionRing (R ‚ß∏ p)) ((FractionRing (R ‚ß∏ p)) ‚äó[R] M) = r) := by\n  sorry", "lean4_code": "import Mathlib\nopen TensorProduct\n\ntheorem free_of_rank_iff (R : Type) [CommRing R] [IsLocalRing R] [IsReduced R]\n    (h : (minimalPrimes R).Finite) (r : ‚Ñï) (M : Type) [AddCommGroup M] [Module R M] [Module.Finite R M] :\n    Module.Free R M ‚àß Module.rank R M = r ‚Üî\n    (Module.rank (IsLocalRing.ResidueField R) ((IsLocalRing.ResidueField R) ‚äó[R] M) = r ‚àß\n    ‚àÄ p ‚àà minimalPrimes R,\n    Module.rank (FractionRing (R ‚ß∏ p)) ((FractionRing (R ‚ß∏ p)) ‚äó[R] M) = r) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "flat_of_flat_over_quotient", "problem_id": "58_flat_of_flat_over_quotient", "informal_prefix": "", "formal_statement": "theorem flat_of_flat_over_quotient (R S : Type) [CommRing R] [CommRing S]\n    [IsLocalRing R] [IsLocalRing S] [IsNoetherianRing R] [IsNoetherianRing S] [Algebra R S]\n    (h_map : Ideal.map (algebraMap R S) (IsLocalRing.maximalIdeal R) ‚â§ IsLocalRing.maximalIdeal S)\n    (M : Type) [AddCommGroup M] [Module S M] [Module R M] [IsScalarTower R S M] [Module.Finite S M]\n    (h_flat_quotient : ‚àÄ (n : ‚Ñï), Module.Flat (R ‚ß∏ (IsLocalRing.maximalIdeal R) ^ n) ((R ‚ß∏ (IsLocalRing.maximalIdeal R) ^ n) ‚äó[R] M)) :\n    Module.Flat R M := by\n  sorry", "lean4_code": "import Mathlib\nopen TensorProduct\n\ntheorem flat_of_flat_over_quotient (R S : Type) [CommRing R] [CommRing S]\n    [IsLocalRing R] [IsLocalRing S] [IsNoetherianRing R] [IsNoetherianRing S] [Algebra R S]\n    (h_map : Ideal.map (algebraMap R S) (IsLocalRing.maximalIdeal R) ‚â§ IsLocalRing.maximalIdeal S)\n    (M : Type) [AddCommGroup M] [Module S M] [Module R M] [IsScalarTower R S M] [Module.Finite S M]\n    (h_flat_quotient : ‚àÄ (n : ‚Ñï), Module.Flat (R ‚ß∏ (IsLocalRing.maximalIdeal R) ^ n) ((R ‚ß∏ (IsLocalRing.maximalIdeal R) ^ n) ‚äó[R] M)) :\n    Module.Flat R M := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "free_dualNumber_and_rank_eq_2", "problem_id": "38_free_dualNumber_and_rank_eq_2", "informal_prefix": "", "formal_statement": "theorem free_dualNumber_and_rank_eq_2 (k : Type) [Field k] :\n    Module.Free (DualNumber k) (S k) ‚àß Module.rank (DualNumber k) (S k) = 2 := by\n  sorry", "lean4_code": "import Mathlib\nopen Polynomial DualNumber\n\ntheorem free_dualNumber_and_rank_eq_2 (k : Type) [Field k] :\n    Module.Free (DualNumber k) (S k) ‚àß Module.rank (DualNumber k) (S k) = 2 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "powerSeries_not_integrallyClosed_of_two_lt_ringKrullDim", "problem_id": "34_powerSeries_not_integrallyClosed_of_two_lt_ringKrullDim", "informal_prefix": "", "formal_statement": "theorem powerSeries_not_integrallyClosed_of_two_lt_ringKrullDim (R : Type) [CommRing R]\n    [IsDomain R] [ValuationRing R] (two_lt : 2 ‚â§ ringKrullDim R) :\n    ¬¨ (IsIntegrallyClosed R‚ü¶X‚üß) := by\n  sorry", "lean4_code": "import Mathlib\nopen PowerSeries\n\ntheorem powerSeries_not_integrallyClosed_of_two_lt_ringKrullDim (R : Type) [CommRing R]\n    [IsDomain R] [ValuationRing R] (two_lt : 2 ‚â§ ringKrullDim R) :\n    ¬¨ (IsIntegrallyClosed R‚ü¶X‚üß) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "ratFunc_square_is_poly_of_orbit_contain_infinite_integer", "problem_id": "96_ratFunc_square_is_poly_of_orbit_contain_infinite_integer", "informal_prefix": "/--\nLet $f(x) \\in \\mathbb{Q}(x)$ be a rational function of degree at least 2, $\\alpha \\in \\mathbb{Q}$.\nIf the orbit $\\mathcal{O}_f(\\alpha)$ contains infinitely many integers, then $f^2(x)$ is a polynomial.\n-/", "formal_statement": "import Mathlib\n\nopen RatFunc\n\n/--\nLet $f(x) \\in \\mathbb{Q}(x)$ be a rational function of degree at least 2, $\\alpha \\in \\mathbb{Q}$.\nIf the orbit $\\mathcal{O}_f(\\alpha)$ contains infinitely many integers, then $f^2(x)$ is a polynomial.\n-/\ntheorem ratFunc_square_is_poly_of_orbit_contain_infinite_integer\n    {f : RatFunc ‚Ñö} (hf : f.num.natDegree ‚â• 2 ‚à® f.denom.natDegree ‚â• 2) {a : ‚Ñö}\n    (h : ‚àÄ n : ‚Ñï, (f.eval (RingHom.id ‚Ñö))^[n] a ‚â† 0) -- exclude the case that the `denom` is zero\n    (ha : {m : ‚Ñ§ | ‚àÉ n : ‚Ñï, m = (f.eval (RingHom.id ‚Ñö))^[n] a}.Infinite) :\n    ‚àÉ g : Polynomial ‚Ñö, g = f.eval C f := by\n  sorry", "lean4_code": "import Mathlib\n\nopen RatFunc\n\n/--\nLet $f(x) \\in \\mathbb{Q}(x)$ be a rational function of degree at least 2, $\\alpha \\in \\mathbb{Q}$.\nIf the orbit $\\mathcal{O}_f(\\alpha)$ contains infinitely many integers, then $f^2(x)$ is a polynomial.\n-/\ntheorem ratFunc_square_is_poly_of_orbit_contain_infinite_integer\n    {f : RatFunc ‚Ñö} (hf : f.num.natDegree ‚â• 2 ‚à® f.denom.natDegree ‚â• 2) {a : ‚Ñö}\n    (h : ‚àÄ n : ‚Ñï, (f.eval (RingHom.id ‚Ñö))^[n] a ‚â† 0) -- exclude the case that the `denom` is zero\n    (ha : {m : ‚Ñ§ | ‚àÉ n : ‚Ñï, m = (f.eval (RingHom.id ‚Ñö))^[n] a}.Infinite) :\n    ‚àÉ g : Polynomial ‚Ñö, g = f.eval C f := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "ufd_quotDetSubOne", "problem_id": "37_ufd_quotDetSubOne", "informal_prefix": "", "formal_statement": "theorem ufd_quotDetSubOne (n : ‚Ñï) (h : n ‚â• 1) : ‚àÉ (h : IsDomain (QuotDetSubOne n)),\n    UniqueFactorizationMonoid (QuotDetSubOne n) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem ufd_quotDetSubOne (n : ‚Ñï) (h : n ‚â• 1) : ‚àÉ (h : IsDomain (QuotDetSubOne n)),\n    UniqueFactorizationMonoid (QuotDetSubOne n) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "finite_algebraic_integers_of_finite_module", "problem_id": "22_finite_algebraic_integers_of_finite_module", "informal_prefix": "", "formal_statement": "theorem finite_algebraic_integers_of_finite_module\n    (F : IntermediateField ‚Ñö ‚ÑÇ) (h_fin : Module.Finite ‚Ñö F) [IsGalois ‚Ñö F]\n    (h : IsMulCommutative (F ‚âÉ‚Çê[‚Ñö] F)) : {x : F | IsIntegral ‚Ñ§ x ‚àß ‚Äñ(x : ‚ÑÇ)‚Äñ = 1}.Finite ‚àß\n    (‚àÄ x : F, IsIntegral ‚Ñ§ x ‚Üí ‚Äñ(x : ‚ÑÇ)‚Äñ = 1 ‚Üí ‚àÉ n,  x ^ n = 1) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem finite_algebraic_integers_of_finite_module\n    (F : IntermediateField ‚Ñö ‚ÑÇ) (h_fin : Module.Finite ‚Ñö F) [IsGalois ‚Ñö F]\n    (h : IsMulCommutative (F ‚âÉ‚Çê[‚Ñö] F)) : {x : F | IsIntegral ‚Ñ§ x ‚àß ‚Äñ(x : ‚ÑÇ)‚Äñ = 1}.Finite ‚àß\n    (‚àÄ x : F, IsIntegral ‚Ñ§ x ‚Üí ‚Äñ(x : ‚ÑÇ)‚Äñ = 1 ‚Üí ‚àÉ n,  x ^ n = 1) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isomorphic_real_of_fractionRing_isomorphic_real_of_UFD", "problem_id": "14_isomorphic_real_of_fractionRing_isomorphic_real_of_UFD", "informal_prefix": "", "formal_statement": "theorem isomorphic_real_of_fractionRing_isomorphic_real_of_UFD (R : Type) [CommRing R] [IsDomain R]\n    [UniqueFactorizationMonoid R] (h : Nonempty ((FractionRing R) ‚âÉ+* ‚Ñù)) :\n    Nonempty (R ‚âÉ+* ‚Ñù) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isomorphic_real_of_fractionRing_isomorphic_real_of_UFD (R : Type) [CommRing R] [IsDomain R]\n    [UniqueFactorizationMonoid R] (h : Nonempty ((FractionRing R) ‚âÉ+* ‚Ñù)) :\n    Nonempty (R ‚âÉ+* ‚Ñù) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "maximal_abelian_normal_subgroup_of_p_group_is_maximal_abelian_subgroup", "problem_id": "5_maximal_abelian_normal_subgroup_of_p_group_is_maximal_abelian_subgroup", "informal_prefix": "", "formal_statement": "theorem maximal_abelian_normal_subgroup_of_p_group_is_maximal_abelian_subgroup\n    (p : ‚Ñï) (hp : p.Prime) (G : Type) [Group G] [Finite G] (h_pgroup : IsPGroup p G)\n    (H : Subgroup G) (h_normal : H.Normal) (h_comm : IsMulCommutative H)\n    (h_maximal_normal_abelian : ‚àÄ (K : Subgroup G), K.Normal ‚Üí IsMulCommutative K ‚Üí H ‚â§ K ‚Üí H = K) :\n    ‚àÄ (K : Subgroup G), IsMulCommutative K ‚Üí H ‚â§ K ‚Üí H = K := by\n  sorry", "lean4_code": "import Mathlib\ntheorem maximal_abelian_normal_subgroup_of_p_group_is_maximal_abelian_subgroup\n    (p : ‚Ñï) (hp : p.Prime) (G : Type) [Group G] [Finite G] (h_pgroup : IsPGroup p G)\n    (H : Subgroup G) (h_normal : H.Normal) (h_comm : IsMulCommutative H)\n    (h_maximal_normal_abelian : ‚àÄ (K : Subgroup G), K.Normal ‚Üí IsMulCommutative K ‚Üí H ‚â§ K ‚Üí H = K) :\n    ‚àÄ (K : Subgroup G), IsMulCommutative K ‚Üí H ‚â§ K ‚Üí H = K := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "a", "problem_id": "92_a", "informal_prefix": "/--\nLet $A$ be a commutative ring with identity, $\\dim A = 1$.\nThen all possible sequences for \\(a_n = dim A[x_1, \\ldots, x_n] ( n \\in \\mathbb{N})\\) are exactly the sequences of the form:\n\\(a_n = 2n+1\\) if \\(n \\le k\\) else \\(a_n = n + k + 1\\), for some \\(k \\in \\mathbb{N} \\cup \\{+\\infty\\}\\).\n-/", "formal_statement": "def a (k : ‚Ñï‚àû) (n : ‚Ñï) :=\n  if h : n ‚â§ k then 2 * n + 1\n  else n + WithTop.untop k (by rintro rfl; exact h le_top) + 1\n\n/--\nLet $A$ be a commutative ring with identity, $\\dim A = 1$.\nThen all possible sequences for \\(a_n = dim A[x_1, \\ldots, x_n] ( n \\in \\mathbb{N})\\) are exactly the sequences of the form:\n\\(a_n = 2n+1\\) if \\(n \\le k\\) else \\(a_n = n + k + 1\\), for some \\(k \\in \\mathbb{N} \\cup \\{+\\infty\\}\\).\n-/", "lean4_code": "import Mathlib\n/--\nLet $A$ be a commutative ring with identity, $\\dim A = 1$.\nThen all possible sequences for \\(a_n = dim A[x_1, \\ldots, x_n] ( n \\in \\mathbb{N})\\) are exactly the sequences of the form:\n\\(a_n = 2n+1\\) if \\(n \\le k\\) else \\(a_n = n + k + 1\\), for some \\(k \\in \\mathbb{N} \\cup \\{+\\infty\\}\\).\n-/\ndef a (k : ‚Ñï‚àû) (n : ‚Ñï) :=\n  if h : n ‚â§ k then 2 * n + 1\n  else n + WithTop.untop k (by rintro rfl; exact h le_top) + 1\n\n/--\nLet $A$ be a commutative ring with identity, $\\dim A = 1$.\nThen all possible sequences for \\(a_n = dim A[x_1, \\ldots, x_n] ( n \\in \\mathbb{N})\\) are exactly the sequences of the form:\n\\(a_n = 2n+1\\) if \\(n \\le k\\) else \\(a_n = n + k + 1\\), for some \\(k \\in \\mathbb{N} \\cup \\{+\\infty\\}\\).\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "dimension_sequences_of_one_dimensional_rings", "problem_id": "92_dimension_sequences_of_one_dimensional_rings", "informal_prefix": "", "formal_statement": "theorem dimension_sequences_of_one_dimensional_rings :\n    (‚àÄ (A : Type) [CommRing A] (h : ringKrullDim A = 1),\n      ‚àÉ (k : ‚Ñï‚àû), (‚àÄ (n : ‚Ñï), ringKrullDim (MvPolynomial (Fin n) A) = a k n)) ‚àß\n    (‚àÄ (k : ‚Ñï), ‚àÉ (A : Type) (_ : CommRing A) (h : ringKrullDim A = 1),\n      (‚àÄ (n : ‚Ñï), ringKrullDim (MvPolynomial (Fin n) A) = a k n)):= by\n  sorry", "lean4_code": "import Mathlib\ntheorem dimension_sequences_of_one_dimensional_rings :\n    (‚àÄ (A : Type) [CommRing A] (h : ringKrullDim A = 1),\n      ‚àÉ (k : ‚Ñï‚àû), (‚àÄ (n : ‚Ñï), ringKrullDim (MvPolynomial (Fin n) A) = a k n)) ‚àß\n    (‚àÄ (k : ‚Ñï), ‚àÉ (A : Type) (_ : CommRing A) (h : ringKrullDim A = 1),\n      (‚àÄ (n : ‚Ñï), ringKrullDim (MvPolynomial (Fin n) A) = a k n)):= by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "ratio_tendsto_one_of_irreducible", "problem_id": "23_ratio_tendsto_one_of_irreducible", "informal_prefix": "", "formal_statement": "theorem ratio_tendsto_one_of_irreducible (f : Polynomial ‚Ñ§) (h_irr : Irreducible f) :\n    Function.rightLim\n    (fun (s : ‚Ñù) ‚Ü¶\n    (tsum (fun p : Nat.Primes ‚Ü¶ (f.rootSet (ZMod p)).ncard * ((p : ‚Ñù) ^ (-s)))) /\n    (tsum (fun p : Nat.Primes ‚Ü¶ (p : ‚Ñù) ^ (-s)))) 1 = 1 := by\n  sorry", "lean4_code": "import Mathlib\ntheorem ratio_tendsto_one_of_irreducible (f : Polynomial ‚Ñ§) (h_irr : Irreducible f) :\n    Function.rightLim\n    (fun (s : ‚Ñù) ‚Ü¶\n    (tsum (fun p : Nat.Primes ‚Ü¶ (f.rootSet (ZMod p)).ncard * ((p : ‚Ñù) ^ (-s)))) /\n    (tsum (fun p : Nat.Primes ‚Ü¶ (p : ‚Ñù) ^ (-s)))) 1 = 1 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_unique_valuation_eq", "problem_id": "59_exists_unique_valuation_eq", "informal_prefix": "", "formal_statement": "theorem exists_unique_valuation_eq (Œ± : ‚Ñù) (h_pos : Œ± > 0) (h_irr : Irrational Œ±)\n    (k : Type) [Field k] : ‚àÉ! (v : AddValuation (FractionRing (MvPolynomial (Fin 2) k)) (WithTop ‚Ñù)),\n    ‚àÄ (f : MvPolynomial (Fin 2) k), v (algebraMap _ _ f) = Finset.inf (Finset.image (fun s ‚Ü¶ ((s 0 + Œ± * s 1) : WithTop ‚Ñù)) f.support) id := by\n  sorry", "lean4_code": "import Mathlib\ntheorem exists_unique_valuation_eq (Œ± : ‚Ñù) (h_pos : Œ± > 0) (h_irr : Irrational Œ±)\n    (k : Type) [Field k] : ‚àÉ! (v : AddValuation (FractionRing (MvPolynomial (Fin 2) k)) (WithTop ‚Ñù)),\n    ‚àÄ (f : MvPolynomial (Fin 2) k), v (algebraMap _ _ f) = Finset.inf (Finset.image (fun s ‚Ü¶ ((s 0 + Œ± * s 1) : WithTop ‚Ñù)) f.support) id := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "moduleDepth", "problem_id": "80_moduleDepth", "informal_prefix": "/--\nConsider the ideal \\( I \\subset k[x_1, \\dots, x_6] \\) generated by the following polynomials:\n\\[\n\\begin{aligned}\nf_1 &= x_2x_4 + x_3x_6, \\\\\nf_2 &= x_3x_5 + x_1x_6, \\\\\nf_3 &= x_1x_2 - x_2x_5 + x_3x_5 - x_5x_6, \\\\\nf_4 &= x_2x_3 + x_2x_4 + x_2x_6 + x_6^2, \\\\\nf_5 &= x_3^2 + x_3x_4 + x_3x_6 - x_4x_6, \\\\\nf_6 &= x_1x_3 + x_1x_4 + x_4x_5 + x_1x_6.\n\\end{aligned}\n\\]\nProve that \\( R/I \\) is Cohen‚ÄìMacaulay of dimension \\( 3 \\).\n-/", "formal_statement": "def moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\nopen MvPolynomial\n\nabbrev target_ring_aux (k : Type) [Field k] :=\n    (MvPolynomial (Fin 6) k) ‚ß∏ Ideal.span ({\n    X 1 * X 3 + X 2 * X 5, X 2 * X 4 + X 0 * X 5, X 0 * X 1 - X 1 * X 4 + X 2 * X 4 - X 4 * X 5,\n    X 1 * X 2 + X 1 * X 3 + X 1 * X 5 + (X 5)^2, (X 2)^2 + X 2 * X 3 + X 2 * X 5 - X 3 * X 5,\n    X 0 * X 2 + X 0 * X 3 + X 3 * X 4 + X 0 * X 5} : Set (MvPolynomial (Fin 6) k))\n\n/--\nConsider the ideal \\( I \\subset k[x_1, \\dots, x_6] \\) generated by the following polynomials:\n\\[\n\\begin{aligned}\nf_1 &= x_2x_4 + x_3x_6, \\\\\nf_2 &= x_3x_5 + x_1x_6, \\\\\nf_3 &= x_1x_2 - x_2x_5 + x_3x_5 - x_5x_6, \\\\\nf_4 &= x_2x_3 + x_2x_4 + x_2x_6 + x_6^2, \\\\\nf_5 &= x_3^2 + x_3x_4 + x_3x_6 - x_4x_6, \\\\\nf_6 &= x_1x_3 + x_1x_4 + x_4x_5 + x_1x_6.\n\\end{aligned}\n\\]\nProve that \\( R/I \\) is Cohen‚ÄìMacaulay of dimension \\( 3 \\).\n-/", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\nopen MvPolynomial\n\n/--\nConsider the ideal \\( I \\subset k[x_1, \\dots, x_6] \\) generated by the following polynomials:\n\\[\n\\begin{aligned}\nf_1 &= x_2x_4 + x_3x_6, \\\\\nf_2 &= x_3x_5 + x_1x_6, \\\\\nf_3 &= x_1x_2 - x_2x_5 + x_3x_5 - x_5x_6, \\\\\nf_4 &= x_2x_3 + x_2x_4 + x_2x_6 + x_6^2, \\\\\nf_5 &= x_3^2 + x_3x_4 + x_3x_6 - x_4x_6, \\\\\nf_6 &= x_1x_3 + x_1x_4 + x_4x_5 + x_1x_6.\n\\end{aligned}\n\\]\nProve that \\( R/I \\) is Cohen‚ÄìMacaulay of dimension \\( 3 \\).\n-/\ndef moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\nopen MvPolynomial\n\nabbrev target_ring_aux (k : Type) [Field k] :=\n    (MvPolynomial (Fin 6) k) ‚ß∏ Ideal.span ({\n    X 1 * X 3 + X 2 * X 5, X 2 * X 4 + X 0 * X 5, X 0 * X 1 - X 1 * X 4 + X 2 * X 4 - X 4 * X 5,\n    X 1 * X 2 + X 1 * X 3 + X 1 * X 5 + (X 5)^2, (X 2)^2 + X 2 * X 3 + X 2 * X 5 - X 3 * X 5,\n    X 0 * X 2 + X 0 * X 3 + X 3 * X 4 + X 0 * X 5} : Set (MvPolynomial (Fin 6) k))\n\n/--\nConsider the ideal \\( I \\subset k[x_1, \\dots, x_6] \\) generated by the following polynomials:\n\\[\n\\begin{aligned}\nf_1 &= x_2x_4 + x_3x_6, \\\\\nf_2 &= x_3x_5 + x_1x_6, \\\\\nf_3 &= x_1x_2 - x_2x_5 + x_3x_5 - x_5x_6, \\\\\nf_4 &= x_2x_3 + x_2x_4 + x_2x_6 + x_6^2, \\\\\nf_5 &= x_3^2 + x_3x_4 + x_3x_6 - x_4x_6, \\\\\nf_6 &= x_1x_3 + x_1x_4 + x_4x_5 + x_1x_6.\n\\end{aligned}\n\\]\nProve that \\( R/I \\) is Cohen‚ÄìMacaulay of dimension \\( 3 \\).\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isCohenMacaulayRing_of_dimension_three", "problem_id": "80_isCohenMacaulayRing_of_dimension_three", "informal_prefix": "", "formal_statement": "theorem isCohenMacaulayRing_of_dimension_three (k : Type) [Field k] :\n    IsCohenMacaulayRing (target_ring_aux k) ‚àß (ringKrullDim (target_ring_aux k) = 3) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\nopen MvPolynomial\n\ntheorem isCohenMacaulayRing_of_dimension_three (k : Type) [Field k] :\n    IsCohenMacaulayRing (target_ring_aux k) ‚àß (ringKrullDim (target_ring_aux k) = 3) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsGradedHom", "problem_id": "45_IsGradedHom", "informal_prefix": "/--\nA linear map `f` between graded modules is a graded homomorphism if it respects the\ngrading structure.\n-/", "formal_statement": "import Mathlib\n\n/--\nA linear map `f` between graded modules is a graded homomorphism if it respects the\ngrading structure.\n-/\ndef IsGradedHom {R M N Œπ : Type} [CommRing R] [AddCommGroup M] [AddCommGroup N]\n    [Module R M] [Module R N] (ùìú : Œπ ‚Üí Submodule R M) (ùí© : Œπ ‚Üí Submodule R N)\n    (f : M ‚Üí‚Çó[R] N) : Prop := ‚àÄ (i : Œπ) (x : ùìú i), f x ‚àà ùí© i\n\n/--\nLet $k$ be a field and $A = k[x_1, \\dots, x_r]$ the polynomial ring in $r$ variables. Let $M$ be a graded module over $A$, and let\n\\[\n0 \\to K \\to L_{r-1} \\to \\cdots \\to L_0 \\to M \\to 0\n\\]\nbe an exact sequence of graded homomorphisms of graded modules, such that $L_0, \\dots, L_{r-1}$ are free. Then $K$ is free. {Gradings of modules are by $\\mathbb{Z}_{\\geq 0}$.}\n-/\ntheorem free_of_free_resolution {k : Type} [Field k] {r : ‚Ñï}\n    (C : ChainComplex (ModuleCat.{0} (MvPolynomial (Fin r) k)) ‚Ñï)\n    (hC : ‚àÄ (n : ‚Ñï), n > (r + 1) ‚Üí CategoryTheory.Limits.IsZero (C.X n))\n    (ùìú : ‚àÄ (n : ‚Ñï), (‚Ñï ‚Üí Submodule (MvPolynomial (Fin r) k) (C.X n)))\n    [hM : ‚àÄ (n : ‚Ñï), DirectSum.Decomposition (ùìú n)]\n    [hM' : ‚àÄ (n : ‚Ñï), SetLike.GradedSMul (MvPolynomial.homogeneousSubmodule (Fin r) k) (ùìú n)]\n    (h_exact : C.Acyclic)\n    (h_gr : ‚àÄ (i j : ‚Ñï), IsGradedHom (ùìú i) (ùìú j) (C.d i j).hom)\n    (h_free : ‚àÄ (n : ‚Ñï), 1 ‚â§ n ‚àß n ‚â§ r ‚Üí Module.Free (MvPolynomial (Fin r) k) (C.X n)) :\n    Module.Free (MvPolynomial (Fin r) k) (C.X (r + 1)) := by\n  sorry", "lean4_code": "import Mathlib\n\n/--\nA linear map `f` between graded modules is a graded homomorphism if it respects the\ngrading structure.\n-/\ndef IsGradedHom {R M N Œπ : Type} [CommRing R] [AddCommGroup M] [AddCommGroup N]\n    [Module R M] [Module R N] (ùìú : Œπ ‚Üí Submodule R M) (ùí© : Œπ ‚Üí Submodule R N)\n    (f : M ‚Üí‚Çó[R] N) : Prop := ‚àÄ (i : Œπ) (x : ùìú i), f x ‚àà ùí© i\n\n/--\nLet $k$ be a field and $A = k[x_1, \\dots, x_r]$ the polynomial ring in $r$ variables. Let $M$ be a graded module over $A$, and let\n\\[\n0 \\to K \\to L_{r-1} \\to \\cdots \\to L_0 \\to M \\to 0\n\\]\nbe an exact sequence of graded homomorphisms of graded modules, such that $L_0, \\dots, L_{r-1}$ are free. Then $K$ is free. {Gradings of modules are by $\\mathbb{Z}_{\\geq 0}$.}\n-/\ntheorem free_of_free_resolution {k : Type} [Field k] {r : ‚Ñï}\n    (C : ChainComplex (ModuleCat.{0} (MvPolynomial (Fin r) k)) ‚Ñï)\n    (hC : ‚àÄ (n : ‚Ñï), n > (r + 1) ‚Üí CategoryTheory.Limits.IsZero (C.X n))\n    (ùìú : ‚àÄ (n : ‚Ñï), (‚Ñï ‚Üí Submodule (MvPolynomial (Fin r) k) (C.X n)))\n    [hM : ‚àÄ (n : ‚Ñï), DirectSum.Decomposition (ùìú n)]\n    [hM' : ‚àÄ (n : ‚Ñï), SetLike.GradedSMul (MvPolynomial.homogeneousSubmodule (Fin r) k) (ùìú n)]\n    (h_exact : C.Acyclic)\n    (h_gr : ‚àÄ (i j : ‚Ñï), IsGradedHom (ùìú i) (ùìú j) (C.d i j).hom)\n    (h_free : ‚àÄ (n : ‚Ñï), 1 ‚â§ n ‚àß n ‚â§ r ‚Üí Module.Free (MvPolynomial (Fin r) k) (C.X n)) :\n    Module.Free (MvPolynomial (Fin r) k) (C.X (r + 1)) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsRegularLocalRing", "problem_id": "69_IsRegularLocalRing", "informal_prefix": "/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/", "formal_statement": "import Mathlib\n\nopen IsLocalRing Polynomial\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/--\nLet \\( A \\) be a Noetherian ring.\nIf \\( R \\) is a regular local ring with maximal ideal \\( \\mathfrak{m} \\) and \\( P \\in \\operatorname{Spec}(R[x]) \\)\nis a prime ideal with \\( \\mathfrak{m} = P \\cap R \\), then \\( R[x]_P \\) is regular.\n-/\ntheorem IsRegularLocalRing.regularAtPrime {R : Type} [CommRing R] [IsRegularLocalRing R]\n    (P : Ideal R[X]) [P.IsPrime] [P.LiesOver (maximalIdeal R)] :\n    IsRegularLocalRing (Localization.AtPrime P) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen IsLocalRing Polynomial\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/--\nLet \\( A \\) be a Noetherian ring.\nIf \\( R \\) is a regular local ring with maximal ideal \\( \\mathfrak{m} \\) and \\( P \\in \\operatorname{Spec}(R[x]) \\)\nis a prime ideal with \\( \\mathfrak{m} = P \\cap R \\), then \\( R[x]_P \\) is regular.\n-/\ntheorem IsRegularLocalRing.regularAtPrime {R : Type} [CommRing R] [IsRegularLocalRing R]\n    (P : Ideal R[X]) [P.IsPrime] [P.LiesOver (maximalIdeal R)] :\n    IsRegularLocalRing (Localization.AtPrime P) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "invertible_iff_codimension_one", "problem_id": "60_invertible_iff_codimension_one", "informal_prefix": "", "formal_statement": "theorem invertible_iff_codimension_one (R : Type) [CommRing R] [IsDomain R] [IsNoetherianRing R]\n    (h_ufd : ‚àÄ (p : Ideal R), (h : p.IsMaximal) ‚Üí UniqueFactorizationMonoid (Localization.AtPrime p))\n    (I : Ideal R) : I.Invertible ‚Üî ‚àÄ (p : associatedPrimes R I), ringKrullDim (R ‚ß∏ p.1) = 1 := by\n  sorry", "lean4_code": "import Mathlib\ntheorem invertible_iff_codimension_one (R : Type) [CommRing R] [IsDomain R] [IsNoetherianRing R]\n    (h_ufd : ‚àÄ (p : Ideal R), (h : p.IsMaximal) ‚Üí UniqueFactorizationMonoid (Localization.AtPrime p))\n    (I : Ideal R) : I.Invertible ‚Üî ‚àÄ (p : associatedPrimes R I), ringKrullDim (R ‚ß∏ p.1) = 1 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsRegularLocalRing", "problem_id": "83_IsRegularLocalRing", "informal_prefix": "/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/", "formal_statement": "import Mathlib\n\nopen IsLocalRing\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/--\nLet \\( f \\colon A \\to B \\) be a flat local homomorphism of Noetherian rings,\nhaving maximal ideals \\( \\mathfrak{M}_A \\) and \\( \\mathfrak{M}_B \\) respectively.\nProve that if \\( A \\) and \\( B/\\mathfrak{M}_A B \\) are regular, then \\( B \\) is regular.\n-/\ntheorem IsRegularLocalRing.flat_local_of_regular {A B : Type} [CommRing A] [CommRing B]\n    [IsRegularLocalRing A] [IsNoetherianRing B] [IsLocalRing B] {f : A ‚Üí+* B} (hfl : IsLocalHom f)\n    (hff : f.Flat) [IsRegularLocalRing (B ‚ß∏ (maximalIdeal A).map f)] : IsRegularLocalRing B := by\n  sorry", "lean4_code": "import Mathlib\n\nopen IsLocalRing\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/--\nLet \\( f \\colon A \\to B \\) be a flat local homomorphism of Noetherian rings,\nhaving maximal ideals \\( \\mathfrak{M}_A \\) and \\( \\mathfrak{M}_B \\) respectively.\nProve that if \\( A \\) and \\( B/\\mathfrak{M}_A B \\) are regular, then \\( B \\) is regular.\n-/\ntheorem IsRegularLocalRing.flat_local_of_regular {A B : Type} [CommRing A] [CommRing B]\n    [IsRegularLocalRing A] [IsNoetherianRing B] [IsLocalRing B] {f : A ‚Üí+* B} (hfl : IsLocalHom f)\n    (hff : f.Flat) [IsRegularLocalRing (B ‚ß∏ (maximalIdeal A).map f)] : IsRegularLocalRing B := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "StepwiseQuotient", "problem_id": "15_StepwiseQuotient", "informal_prefix": "/--\nA subgroup `H‚ÇÅ` is a maximal normal subgroup of `H‚ÇÇ` if it is contained in `H‚ÇÇ`,\nand `H‚ÇÅ` is maximal normal in `H‚ÇÇ`.\n-/", "formal_statement": "import Mathlib\n\n/--\nA subgroup `H‚ÇÅ` is a maximal normal subgroup of `H‚ÇÇ` if it is contained in `H‚ÇÇ`,\nand `H‚ÇÅ` is maximal normal in `H‚ÇÇ`.\n-/\nstructure Subgroup.IsMaximalNormal {G : Type} [Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G) : Prop where\n  le : H‚ÇÅ ‚â§ H‚ÇÇ\n  subgroupOf_normal : (H‚ÇÅ.subgroupOf H‚ÇÇ).Normal\n  is_maximal : ‚àÄ H : Subgroup G, H‚ÇÅ ‚â§ H ‚Üí H ‚â§ H‚ÇÇ ‚Üí (H.subgroupOf H‚ÇÇ).Normal ‚Üí (H = H‚ÇÅ ‚à® H = H‚ÇÇ)\n\n/--\nA normal subgroup composition series of a group `G` is a *maximal* finite chain of normal subgroups\n\\[\n\\{e\\} = G_0 \\triangleleft G_1 \\triangleleft \\cdots \\triangleleft G_n = G\n\\]\nsuch that each quotient `G_{i+1}/G_i` is a simple group.\n-/\nstructure NormalSubgroupCompositionSeries (G : Type) [Group G] : Type where\n  toRelSeries : RelSeries (Subgroup.IsMaximalNormal (G := G))\n  maximal : ‚àÄ s : RelSeries (Subgroup.IsMaximalNormal (G := G)), s.length ‚â§ toRelSeries.length\n\n/--\nThe \\(i\\)-th factor of a normal subgroup composition series, which is the quotient of the \\(i + 1\\)-th\nsubgroup by the previous one.\n-/\ndef StepwiseQuotient {G : Type} [Group G] (s : NormalSubgroupCompositionSeries G) (i : Fin s.toRelSeries.length) :\n    Type :=\n  s.toRelSeries i.succ ‚ß∏ (s.toRelSeries i.castSucc).subgroupOf _\n\n/--\nThe \\(i\\)-th factor of a normal subgroup composition series is a group.\n-/\ninstance {G : Type} [Group G] (s : NormalSubgroupCompositionSeries G) (i : Fin s.toRelSeries.length) :\n    Group (StepwiseQuotient s i) := QuotientGroup.Quotient.group _ (nN := (s.toRelSeries.step i).subgroupOf_normal)\n\n/--\nLet $p,q,r$ be three distinct prime numbers, $t$ a positive integer. Let $G$ be a finite group,\n$H$ a normal subgroup of $G$ such that the cardinality of $G/H$ is $r^{t}$.\nSuppose that there exists a composition series\n\\[\n\\{e\\} = H_0 \\triangleleft H_1 \\triangleleft \\cdots \\triangleleft H_n = H,\n\\]\nof $H$ that satisfies $n=2$, $H_1/H_0 = \\mathbb{Z}/p\\mathbb{Z}$,\n$H_2/H_1 = \\mathbb{Z}/q\\mathbb{Z}$. Further suppose that there exists a composition series\n\\[\n\\{e\\} = G_0 \\triangleleft G_1 \\triangleleft \\cdots \\triangleleft G_n = G,\n\\]\nand positive integers $i < j\\leq n$ such that $G_{i}/G_{i-1} = \\mathbb{Z}/q\\mathbb{Z}$,\n$G_{j}/G_{j-1} = \\mathbb{Z}/p\\mathbb{Z}$. Show that there exists a composition series\n\\[\n\\{e\\} = H_0 \\triangleleft H_1 \\triangleleft \\cdots \\triangleleft H_n = H,\n\\]\nof $H$ that satisfies $n=2$, $H_1/H_0 = \\mathbb{Z}/q\\mathbb{Z}$,\n$H_2/H_1 = \\mathbb{Z}/p\\mathbb{Z}$.\n-/\ntheorem exists_swap_stepwiseQuotient {p q r t : ‚Ñï} (hp : p.Prime) (hq : q.Prime) (hr : r.Prime)\n    (ht : 0 < t) (G : Type) [Group G] [Fintype G] (H : Subgroup G) [H.Normal]\n    (hH : Nat.card (G ‚ß∏ H) = r ^ t) (Hs : NormalSubgroupCompositionSeries H)\n    (hHs: Hs.toRelSeries.length = 2) (hHs0 : StepwiseQuotient Hs ‚ü®0, by omega‚ü© ‚âÉ* ZMod p)\n    (hHs1 : StepwiseQuotient Hs ‚ü®1, by omega‚ü© ‚âÉ* ZMod q)\n    (Gs : NormalSubgroupCompositionSeries G) (i j : Fin Gs.toRelSeries.length) (hij : i < j)\n    (hGi : StepwiseQuotient Gs i ‚âÉ* ZMod q) (hGj : StepwiseQuotient Gs j ‚âÉ* ZMod p) :\n    ‚àÉ (Hs' : NormalSubgroupCompositionSeries H) (hlen : Hs'.toRelSeries.length = 2),\n    Nonempty (StepwiseQuotient Hs' ‚ü®0, by omega‚ü©  ‚âÉ* ZMod q) ‚àß\n    Nonempty (StepwiseQuotient Hs' ‚ü®1, by omega‚ü©  ‚âÉ* ZMod p) := by\n  sorry", "lean4_code": "import Mathlib\n\n/--\nA subgroup `H‚ÇÅ` is a maximal normal subgroup of `H‚ÇÇ` if it is contained in `H‚ÇÇ`,\nand `H‚ÇÅ` is maximal normal in `H‚ÇÇ`.\n-/\nstructure Subgroup.IsMaximalNormal {G : Type} [Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G) : Prop where\n  le : H‚ÇÅ ‚â§ H‚ÇÇ\n  subgroupOf_normal : (H‚ÇÅ.subgroupOf H‚ÇÇ).Normal\n  is_maximal : ‚àÄ H : Subgroup G, H‚ÇÅ ‚â§ H ‚Üí H ‚â§ H‚ÇÇ ‚Üí (H.subgroupOf H‚ÇÇ).Normal ‚Üí (H = H‚ÇÅ ‚à® H = H‚ÇÇ)\n\n/--\nA normal subgroup composition series of a group `G` is a *maximal* finite chain of normal subgroups\n\\[\n\\{e\\} = G_0 \\triangleleft G_1 \\triangleleft \\cdots \\triangleleft G_n = G\n\\]\nsuch that each quotient `G_{i+1}/G_i` is a simple group.\n-/\nstructure NormalSubgroupCompositionSeries (G : Type) [Group G] : Type where\n  toRelSeries : RelSeries (Subgroup.IsMaximalNormal (G := G))\n  maximal : ‚àÄ s : RelSeries (Subgroup.IsMaximalNormal (G := G)), s.length ‚â§ toRelSeries.length\n\n/--\nThe \\(i\\)-th factor of a normal subgroup composition series, which is the quotient of the \\(i + 1\\)-th\nsubgroup by the previous one.\n-/\ndef StepwiseQuotient {G : Type} [Group G] (s : NormalSubgroupCompositionSeries G) (i : Fin s.toRelSeries.length) :\n    Type :=\n  s.toRelSeries i.succ ‚ß∏ (s.toRelSeries i.castSucc).subgroupOf _\n\n/--\nThe \\(i\\)-th factor of a normal subgroup composition series is a group.\n-/\ninstance {G : Type} [Group G] (s : NormalSubgroupCompositionSeries G) (i : Fin s.toRelSeries.length) :\n    Group (StepwiseQuotient s i) := QuotientGroup.Quotient.group _ (nN := (s.toRelSeries.step i).subgroupOf_normal)\n\n/--\nLet $p,q,r$ be three distinct prime numbers, $t$ a positive integer. Let $G$ be a finite group,\n$H$ a normal subgroup of $G$ such that the cardinality of $G/H$ is $r^{t}$.\nSuppose that there exists a composition series\n\\[\n\\{e\\} = H_0 \\triangleleft H_1 \\triangleleft \\cdots \\triangleleft H_n = H,\n\\]\nof $H$ that satisfies $n=2$, $H_1/H_0 = \\mathbb{Z}/p\\mathbb{Z}$,\n$H_2/H_1 = \\mathbb{Z}/q\\mathbb{Z}$. Further suppose that there exists a composition series\n\\[\n\\{e\\} = G_0 \\triangleleft G_1 \\triangleleft \\cdots \\triangleleft G_n = G,\n\\]\nand positive integers $i < j\\leq n$ such that $G_{i}/G_{i-1} = \\mathbb{Z}/q\\mathbb{Z}$,\n$G_{j}/G_{j-1} = \\mathbb{Z}/p\\mathbb{Z}$. Show that there exists a composition series\n\\[\n\\{e\\} = H_0 \\triangleleft H_1 \\triangleleft \\cdots \\triangleleft H_n = H,\n\\]\nof $H$ that satisfies $n=2$, $H_1/H_0 = \\mathbb{Z}/q\\mathbb{Z}$,\n$H_2/H_1 = \\mathbb{Z}/p\\mathbb{Z}$.\n-/\ntheorem exists_swap_stepwiseQuotient {p q r t : ‚Ñï} (hp : p.Prime) (hq : q.Prime) (hr : r.Prime)\n    (ht : 0 < t) (G : Type) [Group G] [Fintype G] (H : Subgroup G) [H.Normal]\n    (hH : Nat.card (G ‚ß∏ H) = r ^ t) (Hs : NormalSubgroupCompositionSeries H)\n    (hHs: Hs.toRelSeries.length = 2) (hHs0 : StepwiseQuotient Hs ‚ü®0, by omega‚ü© ‚âÉ* ZMod p)\n    (hHs1 : StepwiseQuotient Hs ‚ü®1, by omega‚ü© ‚âÉ* ZMod q)\n    (Gs : NormalSubgroupCompositionSeries G) (i j : Fin Gs.toRelSeries.length) (hij : i < j)\n    (hGi : StepwiseQuotient Gs i ‚âÉ* ZMod q) (hGj : StepwiseQuotient Gs j ‚âÉ* ZMod p) :\n    ‚àÉ (Hs' : NormalSubgroupCompositionSeries H) (hlen : Hs'.toRelSeries.length = 2),\n    Nonempty (StepwiseQuotient Hs' ‚ü®0, by omega‚ü©  ‚âÉ* ZMod q) ‚àß\n    Nonempty (StepwiseQuotient Hs' ‚ü®1, by omega‚ü©  ‚âÉ* ZMod p) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "card_minimal_normal_subgroup_le_2", "problem_id": "2_card_minimal_normal_subgroup_le_2", "informal_prefix": "", "formal_statement": "theorem card_minimal_normal_subgroup_le_2 (G : Type) [Group G] [Finite G]\n    (L : Subgroup G) (h_ne_top : L ‚â† ‚ä§) (h_maximal : IsMax (‚ü®L, h_ne_top‚ü© : {H : Subgroup G // H ‚â† ‚ä§}))\n    (h_simple : IsSimpleGroup L) (h_non_comm : ‚àÉ (x y : L), x * y ‚â† y * x) :\n    {H : {H : Subgroup G // H.Normal} | IsMin H}.ncard ‚â§ 2 := by\n  sorry", "lean4_code": "import Mathlib\ntheorem card_minimal_normal_subgroup_le_2 (G : Type) [Group G] [Finite G]\n    (L : Subgroup G) (h_ne_top : L ‚â† ‚ä§) (h_maximal : IsMax (‚ü®L, h_ne_top‚ü© : {H : Subgroup G // H ‚â† ‚ä§}))\n    (h_simple : IsSimpleGroup L) (h_non_comm : ‚àÉ (x y : L), x * y ‚â† y * x) :\n    {H : {H : Subgroup G // H.Normal} | IsMin H}.ncard ‚â§ 2 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "free_of_countably_generated_projective_of_local_infinite_rank", "problem_id": "100_free_of_countably_generated_projective_of_local_infinite_rank", "informal_prefix": "/--\nLet $R$ be a Noetherian ring, $P$ be a countably generated projective $R$-module\nsuch that $P_{\\mathfrak{m}}$ has infinite rank for all maximal ideals $\\mathfrak{m}$ of $R$.\nThen $P$ is free.\n-/", "formal_statement": "import Mathlib\n\nopen Module\n\n/--\nLet $R$ be a Noetherian ring, $P$ be a countably generated projective $R$-module\nsuch that $P_{\\mathfrak{m}}$ has infinite rank for all maximal ideals $\\mathfrak{m}$ of $R$.\nThen $P$ is free.\n-/\ntheorem free_of_countably_generated_projective_of_local_infinite_rank {R : Type} [CommRing R]\n    [IsNoetherianRing R] (P : Type) [AddCommGroup P] [Module R P] [Projective R P]\n    (hcg : ‚àÉ s : Set P, s.Countable ‚àß Submodule.span R s = ‚ä§)\n    (hm : ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí\n      ¬¨ Module.Finite (Localization.AtPrime m) (LocalizedModule.AtPrime m P)) : Free R P := by\n  sorry", "lean4_code": "import Mathlib\n\nopen Module\n\n/--\nLet $R$ be a Noetherian ring, $P$ be a countably generated projective $R$-module\nsuch that $P_{\\mathfrak{m}}$ has infinite rank for all maximal ideals $\\mathfrak{m}$ of $R$.\nThen $P$ is free.\n-/\ntheorem free_of_countably_generated_projective_of_local_infinite_rank {R : Type} [CommRing R]\n    [IsNoetherianRing R] (P : Type) [AddCommGroup P] [Module R P] [Projective R P]\n    (hcg : ‚àÉ s : Set P, s.Countable ‚àß Submodule.span R s = ‚ä§)\n    (hm : ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí\n      ¬¨ Module.Finite (Localization.AtPrime m) (LocalizedModule.AtPrime m P)) : Free R P := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "intermediateField_rank_eq_ringChar", "problem_id": "21_intermediateField_rank_eq_ringChar", "informal_prefix": "", "formal_statement": "theorem intermediateField_rank_eq_ringChar (F : Type) [Field F] (f : Polynomial F) (hf : Irreducible f)\n    (K : Type) [Field K] [Algebra F K] (hK : f.IsSplittingField F K) (Œ± : K)\n    (hŒ± : f.aeval Œ± = 0) (hŒ±1 : f.aeval (Œ± + 1) = 0) :\n    ‚àÉ (E : IntermediateField F K), Module.rank E K = ringChar F := by\n  sorry", "lean4_code": "import Mathlib\nopen Polynomial\n\ntheorem intermediateField_rank_eq_ringChar (F : Type) [Field F] (f : Polynomial F) (hf : Irreducible f)\n    (K : Type) [Field K] [Algebra F K] (hK : f.IsSplittingField F K) (Œ± : K)\n    (hŒ± : f.aeval Œ± = 0) (hŒ±1 : f.aeval (Œ± + 1) = 0) :\n    ‚àÉ (E : IntermediateField F K), Module.rank E K = ringChar F := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "galoisGroup_iso_quaternion_group", "problem_id": "19_galoisGroup_iso_quaternion_group", "informal_prefix": "", "formal_statement": "theorem galoisGroup_iso_quaternion_group : Nonempty ((E ‚âÉ‚Çê[‚Ñö] E) ‚âÉ* (QuaternionGroup 2)) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem galoisGroup_iso_quaternion_group : Nonempty ((E ‚âÉ‚Çê[‚Ñö] E) ‚âÉ* (QuaternionGroup 2)) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "adicCompletion_faithfullyFlat_iff", "problem_id": "51_adicCompletion_faithfullyFlat_iff", "informal_prefix": "", "formal_statement": "theorem adicCompletion_faithfullyFlat_iff (A : Type) [CommRing A] [IsNoetherianRing A]\n    (I : Ideal A) : Module.FaithfullyFlat A (AdicCompletion I A) ‚Üî I ‚â§ Ring.jacobson A := by\n  sorry", "lean4_code": "import Mathlib\ntheorem adicCompletion_faithfullyFlat_iff (A : Type) [CommRing A] [IsNoetherianRing A]\n    (I : Ideal A) : Module.FaithfullyFlat A (AdicCompletion I A) ‚Üî I ‚â§ Ring.jacobson A := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "moduleDepth", "problem_id": "64_moduleDepth", "informal_prefix": "/--\nProve that the homogeneous coordinate ring of a smooth rational quartic in three-space\n\\[\nR=k[s^4, s^3t, st^3, t^4] \\subset k[s,t]\n\\]\nis not Cohen-Macaulay.\n-/", "formal_statement": "def moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\nopen MvPolynomial\n\n/--\nProve that the homogeneous coordinate ring of a smooth rational quartic in three-space\n\\[\nR=k[s^4, s^3t, st^3, t^4] \\subset k[s,t]\n\\]\nis not Cohen-Macaulay.\n-/", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\nopen MvPolynomial\n\n/--\nProve that the homogeneous coordinate ring of a smooth rational quartic in three-space\n\\[\nR=k[s^4, s^3t, st^3, t^4] \\subset k[s,t]\n\\]\nis not Cohen-Macaulay.\n-/\ndef moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\nopen MvPolynomial\n\n/--\nProve that the homogeneous coordinate ring of a smooth rational quartic in three-space\n\\[\nR=k[s^4, s^3t, st^3, t^4] \\subset k[s,t]\n\\]\nis not Cohen-Macaulay.\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "homogeneous_coordinate_ring_not_isCohenMacaulayRing", "problem_id": "64_homogeneous_coordinate_ring_not_isCohenMacaulayRing", "informal_prefix": "", "formal_statement": "theorem homogeneous_coordinate_ring_not_isCohenMacaulayRing (k : Type) [Field k] :\n    ¬¨ IsCohenMacaulayRing (Algebra.adjoin k ({(X 0) ^ 4, (X 0) ^ 3 * X 1,\n      X 0 * (X 1) ^ 3, (X 1) ^ 4} : Set (MvPolynomial (Fin 2) k))) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\nopen MvPolynomial\n\ntheorem homogeneous_coordinate_ring_not_isCohenMacaulayRing (k : Type) [Field k] :\n    ¬¨ IsCohenMacaulayRing (Algebra.adjoin k ({(X 0) ^ 4, (X 0) ^ 3 * X 1,\n      X 0 * (X 1) ^ 3, (X 1) ^ 4} : Set (MvPolynomial (Fin 2) k))) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isNoetherianRing_of_isLocalRing_of_field_inj_of_adicComplete_of_maximalIdeal_finite", "problem_id": "50_isNoetherianRing_of_isLocalRing_of_field_inj_of_adicComplete_of_maximalIdeal_finite", "informal_prefix": "", "formal_statement": "theorem isNoetherianRing_of_isLocalRing_of_field_inj_of_adicComplete_of_maximalIdeal_finite\n    (R : Type) [CommRing R] [IsLocalRing R] [IsAdicComplete (IsLocalRing.maximalIdeal R) R]\n    (k : Type) [Field k] [Algebra k R] [NoZeroSMulDivisors k R]\n    (hfg : (IsLocalRing.maximalIdeal R).FG) : IsNoetherianRing R := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isNoetherianRing_of_isLocalRing_of_field_inj_of_adicComplete_of_maximalIdeal_finite\n    (R : Type) [CommRing R] [IsLocalRing R] [IsAdicComplete (IsLocalRing.maximalIdeal R) R]\n    (k : Type) [Field k] [Algebra k R] [NoZeroSMulDivisors k R]\n    (hfg : (IsLocalRing.maximalIdeal R).FG) : IsNoetherianRing R := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "integrallyClosedIn_of_complement_multiplicatively_closed", "problem_id": "30_integrallyClosedIn_of_complement_multiplicatively_closed", "informal_prefix": "", "formal_statement": "theorem integrallyClosedIn_of_complement_multiplicatively_closed (B : Type) [CommRing B] (A : Subring B)\n    (h : ‚àÄ (x y : B), x ‚àâ A ‚Üí y ‚àâ A ‚Üí x * y ‚àâ A) : IsIntegrallyClosedIn A B := by\n  sorry", "lean4_code": "import Mathlib\ntheorem integrallyClosedIn_of_complement_multiplicatively_closed (B : Type) [CommRing B] (A : Subring B)\n    (h : ‚àÄ (x y : B), x ‚àâ A ‚Üí y ‚àâ A ‚Üí x * y ‚àâ A) : IsIntegrallyClosedIn A B := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isEmpty_isomorphism_UFD_of_quotient", "problem_id": "47_isEmpty_isomorphism_UFD_of_quotient", "informal_prefix": "", "formal_statement": "theorem isEmpty_isomorphism_UFD_of_quotient (k : Type) [Field k] (h_char : ¬¨ CharP k 2)\n    (n : ‚Ñï) (h_ge : n ‚â• 3) (h_odd : Odd n) (t : (Fin n) ‚Üí k) (h_inj : Function.Injective t) :\n    ‚àÉ _ : IsDedekindDomain (A t), Nontrivial (ClassGroup (A t)) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isEmpty_isomorphism_UFD_of_quotient (k : Type) [Field k] (h_char : ¬¨ CharP k 2)\n    (n : ‚Ñï) (h_ge : n ‚â• 3) (h_odd : Odd n) (t : (Fin n) ‚Üí k) (h_inj : Function.Injective t) :\n    ‚àÉ _ : IsDedekindDomain (A t), Nontrivial (ClassGroup (A t)) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsStablyFree", "problem_id": "55_IsStablyFree", "informal_prefix": "/--\nProve that if $M$ is stably free and not finitely generated then $M$ is free.\n-/", "formal_statement": "def IsStablyFree (R : Type) (M : Type) [CommRing R] [AddCommGroup M] [Module R M] : Prop :=\n    ‚àÉ (N : Type) (_ : AddCommGroup N) (_ : Module R N),\n    Module.Finite R N ‚àß Module.Free R N ‚àß Module.Free R (M √ó N)\n\n/--\nProve that if $M$ is stably free and not finitely generated then $M$ is free.\n-/", "lean4_code": "import Mathlib\n/--\nProve that if $M$ is stably free and not finitely generated then $M$ is free.\n-/\ndef IsStablyFree (R : Type) (M : Type) [CommRing R] [AddCommGroup M] [Module R M] : Prop :=\n    ‚àÉ (N : Type) (_ : AddCommGroup N) (_ : Module R N),\n    Module.Finite R N ‚àß Module.Free R N ‚àß Module.Free R (M √ó N)\n\n/--\nProve that if $M$ is stably free and not finitely generated then $M$ is free.\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "stablyFree_iff_free_of_not_fg", "problem_id": "55_stablyFree_iff_free_of_not_fg", "informal_prefix": "", "formal_statement": "theorem stablyFree_iff_free_of_not_fg (R : Type) (M : Type) [CommRing R] [AddCommGroup M]\n    [Module R M] (h : ¬¨ Module.Finite R M) : Module.Free R M ‚Üî IsStablyFree R M := by\n  sorry", "lean4_code": "import Mathlib\ntheorem stablyFree_iff_free_of_not_fg (R : Type) (M : Type) [CommRing R] [AddCommGroup M]\n    [Module R M] (h : ¬¨ Module.Finite R M) : Module.Free R M ‚Üî IsStablyFree R M := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsRegularLocalRing", "problem_id": "74_IsRegularLocalRing", "informal_prefix": "/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/", "formal_statement": "import Mathlib\n\nopen IsLocalRing ModuleCat CategoryTheory\n\ninstance (R : Type) [CommRing R] : CategoryTheory.HasExt.{0} (ModuleCat.{0} R) :=\n  CategoryTheory.hasExt_of_enoughProjectives.{0} (ModuleCat.{0} R)\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\nvariable {R : Type} [CommRing R]\n\n/--\nLet $R$ be a regular local ring and let $x_1, \\dots, x_c$ be a regular sequence in $R$.\nLet $y \\in R$, $y \\notin (x_1, \\dots, x_c)$, and set $J := ((x_1, \\dots, x_c) : y)$. Prove that $R/J$ is Gorenstein.\n-/\ntheorem IsRegularLocalRing.gorensteinAtRegularSequence {R : Type} [CommRing R]\n    [IsRegularLocalRing R] {rs : List R} (reg : RingTheory.Sequence.IsRegular R rs) (y : R)\n    (h : y ‚àâ Ideal.ofList rs) : IsGorensteinRing (R ‚ß∏ (Ideal.ofList rs / Ideal.span {y})) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen IsLocalRing ModuleCat CategoryTheory\n\ninstance (R : Type) [CommRing R] : CategoryTheory.HasExt.{0} (ModuleCat.{0} R) :=\n  CategoryTheory.hasExt_of_enoughProjectives.{0} (ModuleCat.{0} R)\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\nvariable {R : Type} [CommRing R]\n\n/--\nLet $R$ be a regular local ring and let $x_1, \\dots, x_c$ be a regular sequence in $R$.\nLet $y \\in R$, $y \\notin (x_1, \\dots, x_c)$, and set $J := ((x_1, \\dots, x_c) : y)$. Prove that $R/J$ is Gorenstein.\n-/\ntheorem IsRegularLocalRing.gorensteinAtRegularSequence {R : Type} [CommRing R]\n    [IsRegularLocalRing R] {rs : List R} (reg : RingTheory.Sequence.IsRegular R rs) (y : R)\n    (h : y ‚àâ Ideal.ofList rs) : IsGorensteinRing (R ‚ß∏ (Ideal.ofList rs / Ideal.span {y})) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isAbsolutelyFlat_iff_principal_ideal_idempotent", "problem_id": "48_isAbsolutelyFlat_iff_principal_ideal_idempotent", "informal_prefix": "", "formal_statement": "theorem isAbsolutelyFlat_iff_principal_ideal_idempotent (R : Type) [CommRing R] :\n    IsAbsolutelyFlat R ‚Üî (‚àÄ I : Ideal R, I.IsPrincipal ‚Üí I ^ 2 = I) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isAbsolutelyFlat_iff_principal_ideal_idempotent (R : Type) [CommRing R] :\n    IsAbsolutelyFlat R ‚Üî (‚àÄ I : Ideal R, I.IsPrincipal ‚Üí I ^ 2 = I) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "UFD_of_ge_5", "problem_id": "31_UFD_of_ge_5", "informal_prefix": "", "formal_statement": "theorem UFD_of_ge_5 (n : ‚Ñï) (h : n ‚â• 5) :\n    ‚àÉ (h : IsDomain (R n)), UniqueFactorizationMonoid (R n) := by\n  sorry", "lean4_code": "import Mathlib\nopen MvPolynomial\n\ntheorem UFD_of_ge_5 (n : ‚Ñï) (h : n ‚â• 5) :\n    ‚àÉ (h : IsDomain (R n)), UniqueFactorizationMonoid (R n) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "equiv_of_aut_equiv", "problem_id": "99_equiv_of_aut_equiv", "informal_prefix": "/--\nLet $A$ be a finite-type $\\mathbb{C}$-algebra, $n \\in \\mathbb{N}$, $n \\ge 1$. If $A$ is a domain,\nand $\\mathrm{Aut}_\\mathbb{C}\\ A$ is isomorphic to $\\mathrm{Aut}_\\mathbb{C}\\ \\mathbb{C}[x_1, \\dots, x_n]$,\nthen $A$ is isomorphic to $\\mathbb{C}[x_1, \\dots, x_n]$ as $\\mathbb{C}$-algebras.\n-/", "formal_statement": "import Mathlib\n\n/--\nLet $A$ be a finite-type $\\mathbb{C}$-algebra, $n \\in \\mathbb{N}$, $n \\ge 1$. If $A$ is a domain,\nand $\\mathrm{Aut}_\\mathbb{C}\\ A$ is isomorphic to $\\mathrm{Aut}_\\mathbb{C}\\ \\mathbb{C}[x_1, \\dots, x_n]$,\nthen $A$ is isomorphic to $\\mathbb{C}[x_1, \\dots, x_n]$ as $\\mathbb{C}$-algebras.\n-/\ntheorem equiv_of_aut_equiv {A : Type} [CommRing A] [IsDomain A] [Algebra ‚ÑÇ A]\n    [Algebra.FiniteType ‚ÑÇ A] {n : ‚Ñï} (hn : n ‚â• 1)\n    (e : (A ‚âÉ‚Çê[‚ÑÇ] A) ‚âÉ* (MvPolynomial (Fin n) ‚ÑÇ ‚âÉ‚Çê[‚ÑÇ] MvPolynomial (Fin n) ‚ÑÇ)) :\n    Nonempty (A ‚âÉ‚Çê[‚ÑÇ] MvPolynomial (Fin n) ‚ÑÇ) := by\n  sorry", "lean4_code": "import Mathlib\n\n/--\nLet $A$ be a finite-type $\\mathbb{C}$-algebra, $n \\in \\mathbb{N}$, $n \\ge 1$. If $A$ is a domain,\nand $\\mathrm{Aut}_\\mathbb{C}\\ A$ is isomorphic to $\\mathrm{Aut}_\\mathbb{C}\\ \\mathbb{C}[x_1, \\dots, x_n]$,\nthen $A$ is isomorphic to $\\mathbb{C}[x_1, \\dots, x_n]$ as $\\mathbb{C}$-algebras.\n-/\ntheorem equiv_of_aut_equiv {A : Type} [CommRing A] [IsDomain A] [Algebra ‚ÑÇ A]\n    [Algebra.FiniteType ‚ÑÇ A] {n : ‚Ñï} (hn : n ‚â• 1)\n    (e : (A ‚âÉ‚Çê[‚ÑÇ] A) ‚âÉ* (MvPolynomial (Fin n) ‚ÑÇ ‚âÉ‚Çê[‚ÑÇ] MvPolynomial (Fin n) ‚ÑÇ)) :\n    Nonempty (A ‚âÉ‚Çê[‚ÑÇ] MvPolynomial (Fin n) ‚ÑÇ) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "galoisGroup_iso_of_distinct_primes", "problem_id": "24_galoisGroup_iso_of_distinct_primes", "informal_prefix": "/--\nThe field $K = \\mathbb{Q}(\\sqrt{p_1}, \\dots, \\sqrt{p_r})$\nfor a finite list of integers $p_1, \\dots, p_r$.\n-/", "formal_statement": "import Mathlib\n\n/--\nThe field $K = \\mathbb{Q}(\\sqrt{p_1}, \\dots, \\sqrt{p_r})$\nfor a finite list of integers $p_1, \\dots, p_r$.\n-/\nabbrev RatAdjoinSqrt {I : Type} (p : I ‚Üí ‚Ñï) : Type :=\n  Algebra.adjoin ‚Ñö (Set.range (fun i ‚Ü¶ Real.sqrt (p i)))\n\n/--\nLet $p_1, \\dots, p_r$ be $r$ different prime numbers.\nProve that the Galois group of $K =\\mathbb{Q}(\\sqrt{p_1}, \\dots, \\sqrt{p_r})$ over $\\mathbb{Q}$\nis $(\\mathbb{Z}/2\\mathbb{Z})^r$, here $\\mathbb{Z}/2\\mathbb{Z}$ is the cyclic group of order 2.\n-/\ntheorem galoisGroup_iso_of_distinct_primes {I : Type} [Finite I] (p : I ‚Üí ‚Ñï)\n    (hp : ‚àÄ (i : I), (p i).Prime) (h_inj : p.Injective) :\n    Nonempty ((RatAdjoinSqrt p ‚âÉ‚Çê[‚Ñö] RatAdjoinSqrt p) ‚âÉ* (Multiplicative (I ‚Üí (ZMod 2)))) := by\n  sorry", "lean4_code": "import Mathlib\n\n/--\nThe field $K = \\mathbb{Q}(\\sqrt{p_1}, \\dots, \\sqrt{p_r})$\nfor a finite list of integers $p_1, \\dots, p_r$.\n-/\nabbrev RatAdjoinSqrt {I : Type} (p : I ‚Üí ‚Ñï) : Type :=\n  Algebra.adjoin ‚Ñö (Set.range (fun i ‚Ü¶ Real.sqrt (p i)))\n\n/--\nLet $p_1, \\dots, p_r$ be $r$ different prime numbers.\nProve that the Galois group of $K =\\mathbb{Q}(\\sqrt{p_1}, \\dots, \\sqrt{p_r})$ over $\\mathbb{Q}$\nis $(\\mathbb{Z}/2\\mathbb{Z})^r$, here $\\mathbb{Z}/2\\mathbb{Z}$ is the cyclic group of order 2.\n-/\ntheorem galoisGroup_iso_of_distinct_primes {I : Type} [Finite I] (p : I ‚Üí ‚Ñï)\n    (hp : ‚àÄ (i : I), (p i).Prime) (h_inj : p.Injective) :\n    Nonempty ((RatAdjoinSqrt p ‚âÉ‚Çê[‚Ñö] RatAdjoinSqrt p) ‚âÉ* (Multiplicative (I ‚Üí (ZMod 2)))) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "sylow_subgroup_not_normal_of_maximal_intersection", "problem_id": "9_sylow_subgroup_not_normal_of_maximal_intersection", "informal_prefix": "", "formal_statement": "theorem sylow_subgroup_not_normal_of_maximal_intersection (G : Type) [Finite G] [Group G]\n    (p : ‚Ñï) [Fact (Nat.Prime p)] (S T : Sylow p G) (h_ne : S ‚â† T)\n    (h_maximal : ‚àÄ (S' T' : Sylow p G), S' ‚â† T' ‚Üí\n    ((S' : Set G) ‚äì T').ncard ‚â§ ((S : Set G) ‚äì T).ncard) :\n    ‚àÄ (P : Sylow p ((S : Subgroup G) ‚äì T).normalizer), ¬¨ P.Normal := by\n  sorry", "lean4_code": "import Mathlib\ntheorem sylow_subgroup_not_normal_of_maximal_intersection (G : Type) [Finite G] [Group G]\n    (p : ‚Ñï) [Fact (Nat.Prime p)] (S T : Sylow p G) (h_ne : S ‚â† T)\n    (h_maximal : ‚àÄ (S' T' : Sylow p G), S' ‚â† T' ‚Üí\n    ((S' : Set G) ‚äì T').ncard ‚â§ ((S : Set G) ‚äì T).ncard) :\n    ‚àÄ (P : Sylow p ((S : Subgroup G) ‚äì T).normalizer), ¬¨ P.Normal := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsCompletelyIntegrallyClosed", "problem_id": "57_IsCompletelyIntegrallyClosed", "informal_prefix": "/--\nLet \\( A \\) be a domain. Show that if \\( A \\) is completely integrally closed, so is \\( A[X] \\). -/", "formal_statement": "def IsCompletelyIntegrallyClosed (A : Type) [CommRing A] [IsDomain A] : Prop :=\n  ‚àÄ x : FractionRing A, IsAlmostIntegral x ‚Üí ‚àÉ y : A, x = algebraMap A (FractionRing A) y\n\n/--\nLet \\( A \\) be a domain. Show that if \\( A \\) is completely integrally closed, so is \\( A[X] \\). -/", "lean4_code": "import Mathlib\n/--\nLet \\( A \\) be a domain. Show that if \\( A \\) is completely integrally closed, so is \\( A[X] \\). -/\ndef IsCompletelyIntegrallyClosed (A : Type) [CommRing A] [IsDomain A] : Prop :=\n  ‚àÄ x : FractionRing A, IsAlmostIntegral x ‚Üí ‚àÉ y : A, x = algebraMap A (FractionRing A) y\n\n/--\nLet \\( A \\) be a domain. Show that if \\( A \\) is completely integrally closed, so is \\( A[X] \\). -/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_polynomial_ringEquiv_isEmpty_ringEquiv", "problem_id": "87_exists_polynomial_ringEquiv_isEmpty_ringEquiv", "informal_prefix": "", "formal_statement": "theorem exists_polynomial_ringEquiv_isEmpty_ringEquiv :\n    ‚àÉ (R S : Type) (_ : CommRing R) (_ : CommRing S),\n    Nonempty ((Polynomial R) ‚âÉ+* (Polynomial S)) ‚àß IsEmpty (R ‚âÉ+* S) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem exists_polynomial_ringEquiv_isEmpty_ringEquiv :\n    ‚àÉ (R S : Type) (_ : CommRing R) (_ : CommRing S),\n    Nonempty ((Polynomial R) ‚âÉ+* (Polynomial S)) ‚àß IsEmpty (R ‚âÉ+* S) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "normalClosure_isPExtension_of_isPExtension", "problem_id": "16_normalClosure_isPExtension_of_isPExtension", "informal_prefix": "", "formal_statement": "theorem normalClosure_isPExtension_of_isPExtension (F E : Type) [Field F] [Field E]\n    [Algebra F E] (L : IntermediateField F E) (K : IntermediateField F L) (p : ‚Ñï) (hp : p.Prime)\n    [IsPExtension F K p] [IsGalois K L] [IsPExtension K L p]\n    (h_normalClosure : IsNormalClosure F L E) : IsPExtension F E p := by\n  sorry", "lean4_code": "import Mathlib\ntheorem normalClosure_isPExtension_of_isPExtension (F E : Type) [Field F] [Field E]\n    [Algebra F E] (L : IntermediateField F E) (K : IntermediateField F L) (p : ‚Ñï) (hp : p.Prime)\n    [IsPExtension F K p] [IsGalois K L] [IsPExtension K L p]\n    (h_normalClosure : IsNormalClosure F L E) : IsPExtension F E p := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exist_euclideanDomain_not_norm_nat", "problem_id": "85_exist_euclideanDomain_not_norm_nat", "informal_prefix": "", "formal_statement": "theorem exist_euclideanDomain_not_norm_nat :\n    ‚àÉ (R : Type) (_ : EuclideanDomain R), IsEmpty (EuclideanNormNat R) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem exist_euclideanDomain_not_norm_nat :\n    ‚àÉ (R : Type) (_ : EuclideanDomain R), IsEmpty (EuclideanNormNat R) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isGorensteinRing_quot_x2_sub_y2_y2_sub_z2_xy_yz_zx", "problem_id": "53_isGorensteinRing_quot_x2_sub_y2_y2_sub_z2_xy_yz_zx", "informal_prefix": "", "formal_statement": "theorem isGorensteinRing_quot_x2_sub_y2_y2_sub_z2_xy_yz_zx (k : Type) [Field k] :\n    IsGorensteinRing <| MvPolynomial (Fin 3) k ‚ß∏ Ideal.span ({(X 0)^ 2 - (X 1)^2, (X 1)^2 - (X 2)^2,\n    (X 0) * (X 1), (X 1) * (X 2), (X 2) * (X 0)} : Set (MvPolynomial (Fin 3) k)) := by\n  sorry", "lean4_code": "import Mathlib\nopen IsLocalRing ModuleCat CategoryTheory MvPolynomial\n\ntheorem isGorensteinRing_quot_x2_sub_y2_y2_sub_z2_xy_yz_zx (k : Type) [Field k] :\n    IsGorensteinRing <| MvPolynomial (Fin 3) k ‚ß∏ Ideal.span ({(X 0)^ 2 - (X 1)^2, (X 1)^2 - (X 2)^2,\n    (X 0) * (X 1), (X 1) * (X 2), (X 2) * (X 0)} : Set (MvPolynomial (Fin 3) k)) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "moduleDepth", "problem_id": "72_moduleDepth", "informal_prefix": "/--\nLet \\( R \\) be a Noetherian ring. Let \\( M \\) be a Cohen-Macaulay module over \\( R \\).\nThen \\( M \\otimes_R R[x_1, \\dots, x_n] \\) is a Cohen-Macaulay module over \\( R[x_1, \\dots, x_n] \\).\n-/", "formal_statement": "def moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nclass ModuleCat.IsCohenMacaulay [IsLocalRing R] (M : ModuleCat.{0} R) : Prop where\n  depth_eq_dim : Subsingleton M ‚à® Module.supportDim R M = IsLocalRing.depth M\n\nvariable (R)\n\nclass Module.IsCohenMacaulay (M : Type) [AddCommGroup M] [Module R M] : Prop where\n  depth_eq_dim : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), (ModuleCat.of (Localization.AtPrime p)\n    (LocalizedModule.AtPrime p M)).IsCohenMacaulay\n\nend\n\nopen TensorProduct\n\n/--\nLet \\( R \\) be a Noetherian ring. Let \\( M \\) be a Cohen-Macaulay module over \\( R \\).\nThen \\( M \\otimes_R R[x_1, \\dots, x_n] \\) is a Cohen-Macaulay module over \\( R[x_1, \\dots, x_n] \\).\n-/", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\nopen TensorProduct\n\n/--\nLet \\( R \\) be a Noetherian ring. Let \\( M \\) be a Cohen-Macaulay module over \\( R \\).\nThen \\( M \\otimes_R R[x_1, \\dots, x_n] \\) is a Cohen-Macaulay module over \\( R[x_1, \\dots, x_n] \\).\n-/\ndef moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nclass ModuleCat.IsCohenMacaulay [IsLocalRing R] (M : ModuleCat.{0} R) : Prop where\n  depth_eq_dim : Subsingleton M ‚à® Module.supportDim R M = IsLocalRing.depth M\n\nvariable (R)\n\nclass Module.IsCohenMacaulay (M : Type) [AddCommGroup M] [Module R M] : Prop where\n  depth_eq_dim : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), (ModuleCat.of (Localization.AtPrime p)\n    (LocalizedModule.AtPrime p M)).IsCohenMacaulay\n\nend\n\nopen TensorProduct\n\n/--\nLet \\( R \\) be a Noetherian ring. Let \\( M \\) be a Cohen-Macaulay module over \\( R \\).\nThen \\( M \\otimes_R R[x_1, \\dots, x_n] \\) is a Cohen-Macaulay module over \\( R[x_1, \\dots, x_n] \\).\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isCohenMacaulay_extendScalars_over_mvPolynomial_of_isCohenMacaulay", "problem_id": "72_isCohenMacaulay_extendScalars_over_mvPolynomial_of_isCohenMacaulay", "informal_prefix": "", "formal_statement": "theorem isCohenMacaulay_extendScalars_over_mvPolynomial_of_isCohenMacaulay\n    (R : Type) [CommRing R] (M : Type) [AddCommGroup M] [Module R M]\n    [IsNoetherianRing R] [Module.IsCohenMacaulay R M] (n : ‚Ñï) :\n    Module.IsCohenMacaulay (MvPolynomial (Fin n) R) ((MvPolynomial (Fin n) R) ‚äó[R] M) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Abelian\nopen TensorProduct\n\ntheorem isCohenMacaulay_extendScalars_over_mvPolynomial_of_isCohenMacaulay\n    (R : Type) [CommRing R] (M : Type) [AddCommGroup M] [Module R M]\n    [IsNoetherianRing R] [Module.IsCohenMacaulay R M] (n : ‚Ñï) :\n    Module.IsCohenMacaulay (MvPolynomial (Fin n) R) ((MvPolynomial (Fin n) R) ‚äó[R] M) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "fixedField_eq_algebra_adjoin", "problem_id": "25_fixedField_eq_algebra_adjoin", "informal_prefix": "", "formal_statement": "theorem fixedField_eq_algebra_adjoin :\n    Nonempty ((RatFunc (ZMod 2) ‚âÉ+* RatFunc (ZMod 2)) ‚âÉ* (Equiv.Perm (Fin 3))) ‚àß\n    IntermediateField.fixedField (F := ZMod 2) (E := RatFunc (ZMod 2)) ‚ä§ =\n    IntermediateField.adjoin (ZMod 2) {((.X ^ 4 - .X) ^ 3 / (.X ^ 2 - .X) ^ 5 : (RatFunc (ZMod 2)))} := by\n  sorry", "lean4_code": "import Mathlib\ntheorem fixedField_eq_algebra_adjoin :\n    Nonempty ((RatFunc (ZMod 2) ‚âÉ+* RatFunc (ZMod 2)) ‚âÉ* (Equiv.Perm (Fin 3))) ‚àß\n    IntermediateField.fixedField (F := ZMod 2) (E := RatFunc (ZMod 2)) ‚ä§ =\n    IntermediateField.adjoin (ZMod 2) {((.X ^ 4 - .X) ^ 3 / (.X ^ 2 - .X) ^ 5 : (RatFunc (ZMod 2)))} := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "projective_of_faithfullyFlat_base_change", "problem_id": "56_projective_of_faithfullyFlat_base_change", "informal_prefix": "", "formal_statement": "theorem projective_of_faithfullyFlat_base_change (R S M : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Module.FaithfullyFlat R S] [AddCommGroup M] [Module R M]\n    [Module.Projective S (TensorProduct R S M)] : Module.Projective R M := by\n  sorry", "lean4_code": "import Mathlib\ntheorem projective_of_faithfullyFlat_base_change (R S M : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Module.FaithfullyFlat R S] [AddCommGroup M] [Module R M]\n    [Module.Projective S (TensorProduct R S M)] : Module.Projective R M := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "not_zero_divisor_of_hausdorff_of_der_eq_one", "problem_id": "54_not_zero_divisor_of_hausdorff_of_der_eq_one", "informal_prefix": "", "formal_statement": "theorem not_zero_divisor_of_hausdorff_of_der_eq_one (A : Type) [CommRing A] [Algebra ‚Ñö A]\n    (x : A) (D : Derivation ‚Ñ§ A A) (h_dx : D x = 1) (h_hausdorff : IsHausdorff (Ideal.span {x}) A) :\n    x ‚àà nonZeroDivisors A := by\n  sorry", "lean4_code": "import Mathlib\ntheorem not_zero_divisor_of_hausdorff_of_der_eq_one (A : Type) [CommRing A] [Algebra ‚Ñö A]\n    (x : A) (D : Derivation ‚Ñ§ A A) (h_dx : D x = 1) (h_hausdorff : IsHausdorff (Ideal.span {x}) A) :\n    x ‚àà nonZeroDivisors A := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "UFD_of_adicCompletion_UFD", "problem_id": "32_UFD_of_adicCompletion_UFD", "informal_prefix": "", "formal_statement": "theorem UFD_of_adicCompletion_UFD (R : Type) [CommRing R] [IsLocalRing R] [IsNoetherianRing R]\n    [IsDomain (AdicCompletion (maximalIdeal R) R)]\n    [UniqueFactorizationMonoid (AdicCompletion (maximalIdeal R) R)] :\n    ‚àÉ (h : IsDomain R), UniqueFactorizationMonoid R := by\n  sorry", "lean4_code": "import Mathlib\nopen IsLocalRing\n\ntheorem UFD_of_adicCompletion_UFD (R : Type) [CommRing R] [IsLocalRing R] [IsNoetherianRing R]\n    [IsDomain (AdicCompletion (maximalIdeal R) R)]\n    [UniqueFactorizationMonoid (AdicCompletion (maximalIdeal R) R)] :\n    ‚àÉ (h : IsDomain R), UniqueFactorizationMonoid R := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "quotient_not_UFD", "problem_id": "88_quotient_not_UFD", "informal_prefix": "", "formal_statement": "theorem quotient_not_UFD :\n    ‚àÉ (h : IsDomain R),\n    (UniqueFactorizationMonoid R) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem quotient_not_UFD :\n    ‚àÉ (h : IsDomain R),\n    (UniqueFactorizationMonoid R) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_integral_finiteType_not_finiteDimensional", "problem_id": "93_exists_integral_finiteType_not_finiteDimensional", "informal_prefix": "", "formal_statement": "theorem exists_integral_finiteType_not_finiteDimensional : ‚àÉ (k A : Type) (_ : Field k)\n    (_ : Ring A) (_ : Algebra k A),\n    Algebra.IsIntegral k A ‚àß Algebra.FiniteType k A ‚àß ¬¨ FiniteDimensional k A := by\n  sorry", "lean4_code": "import Mathlib\ntheorem exists_integral_finiteType_not_finiteDimensional : ‚àÉ (k A : Type) (_ : Field k)\n    (_ : Ring A) (_ : Algebra k A),\n    Algebra.IsIntegral k A ‚àß Algebra.FiniteType k A ‚àß ¬¨ FiniteDimensional k A := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "adicCompletion_equiv_of_smooth", "problem_id": "62_adicCompletion_equiv_of_smooth", "informal_prefix": "", "formal_statement": "theorem adicCompletion_equiv_of_smooth (R S : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Algebra.Smooth R S] (œÉ : S ‚Üí+* R)\n    (h : Function.LeftInverse œÉ (algebraMap R S)) (hf : Module.Free R œÉ.ker.Cotangent) :\n    ‚àÉ d : ‚Ñï, Nonempty (AdicCompletion (RingHom.ker œÉ) S ‚âÉ‚Çê[R] MvPowerSeries (Fin d) R) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem adicCompletion_equiv_of_smooth (R S : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Algebra.Smooth R S] (œÉ : S ‚Üí+* R)\n    (h : Function.LeftInverse œÉ (algebraMap R S)) (hf : Module.Free R œÉ.ker.Cotangent) :\n    ‚àÉ d : ‚Ñï, Nonempty (AdicCompletion (RingHom.ker œÉ) S ‚âÉ‚Çê[R] MvPowerSeries (Fin d) R) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "dimension_convex", "problem_id": "86_dimension_convex", "informal_prefix": "", "formal_statement": "theorem dimension_convex (A : Type) [CommRing A] :\n    ringKrullDim (MvPolynomial A (Fin 2)) + ringKrullDim A ‚â§ 2 * ringKrullDim (Polynomial A) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem dimension_convex (A : Type) [CommRing A] :\n    ringKrullDim (MvPolynomial A (Fin 2)) + ringKrullDim A ‚â§ 2 * ringKrullDim (Polynomial A) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "quaternionAlgebra_isomorphic_to_matrix_ring_or_quaternion_ring", "problem_id": "8_quaternionAlgebra_isomorphic_to_matrix_ring_or_quaternion_ring", "informal_prefix": "", "formal_statement": "theorem quaternionAlgebra_isomorphic_to_matrix_ring_or_quaternion_ring\n    (A B : ‚Ñö) (ha : A ‚â† 0) (hb : B ‚â† 0) :\n    ((Nonempty (‚Ñç[‚Ñù, A, B] ‚âÉ‚Çê[‚Ñù] ‚Ñç[‚Ñù, -1, -1])) ‚à® (Nonempty (‚Ñç[‚Ñù, A, B] ‚âÉ‚Çê[‚Ñù] Matrix (Fin 2) (Fin 2) ‚Ñù)))\n    ‚àß IsEmpty (Matrix (Fin 2) (Fin 2) ‚Ñù ‚âÉ‚Çê[‚Ñù] ‚Ñç[‚Ñù, -1, -1]) := by\n  sorry", "lean4_code": "import Mathlib\nopen Quaternion\n\ntheorem quaternionAlgebra_isomorphic_to_matrix_ring_or_quaternion_ring\n    (A B : ‚Ñö) (ha : A ‚â† 0) (hb : B ‚â† 0) :\n    ((Nonempty (‚Ñç[‚Ñù, A, B] ‚âÉ‚Çê[‚Ñù] ‚Ñç[‚Ñù, -1, -1])) ‚à® (Nonempty (‚Ñç[‚Ñù, A, B] ‚âÉ‚Çê[‚Ñù] Matrix (Fin 2) (Fin 2) ‚Ñù)))\n    ‚àß IsEmpty (Matrix (Fin 2) (Fin 2) ‚Ñù ‚âÉ‚Çê[‚Ñù] ‚Ñç[‚Ñù, -1, -1]) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isNoetherianRing_and_krullDim_eq_top", "problem_id": "41_isNoetherianRing_and_krullDim_eq_top", "informal_prefix": "", "formal_statement": "theorem isNoetherianRing_and_krullDim_eq_top (k : Type) [Field k] (m : ‚Ñï ‚Üí ‚Ñï) (h : StrictMono m) (h_diff_mono : StrictMono (fun (i : ‚Ñï) ‚Ü¶ m (i + 1) - m i)) :\n    IsNoetherianRing (SInvA k m) ‚àß\n    ringKrullDim (SInvA k m) = ‚ä§ := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isNoetherianRing_and_krullDim_eq_top (k : Type) [Field k] (m : ‚Ñï ‚Üí ‚Ñï) (h : StrictMono m) (h_diff_mono : StrictMono (fun (i : ‚Ñï) ‚Ü¶ m (i + 1) - m i)) :\n    IsNoetherianRing (SInvA k m) ‚àß\n    ringKrullDim (SInvA k m) = ‚ä§ := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "quot_x2_sub_y2_y2_sub_z2_xy_yz_zx_not_global_complete_intersection", "problem_id": "44_quot_x2_sub_y2_y2_sub_z2_xy_yz_zx_not_global_complete_intersection", "informal_prefix": "", "formal_statement": "theorem quot_x2_sub_y2_y2_sub_z2_xy_yz_zx_not_global_complete_intersection (k : Type) [Field k] :\n    ¬¨ IsGlobalCompleteIntersection k (MvPolynomial (Fin 3) k ‚ß∏ Ideal.span\n    ({(X 0)^ 2 - (X 1)^2, (X 1)^2 - (X 2)^2, (X 0) * (X 1), (X 1) * (X 2), (X 2) * (X 0)} :\n    Set (MvPolynomial (Fin 3) k))) := by\n  sorry", "lean4_code": "import Mathlib\nopen MvPolynomial\n\ntheorem quot_x2_sub_y2_y2_sub_z2_xy_yz_zx_not_global_complete_intersection (k : Type) [Field k] :\n    ¬¨ IsGlobalCompleteIntersection k (MvPolynomial (Fin 3) k ‚ß∏ Ideal.span\n    ({(X 0)^ 2 - (X 1)^2, (X 1)^2 - (X 2)^2, (X 0) * (X 1), (X 1) * (X 2), (X 2) * (X 0)} :\n    Set (MvPolynomial (Fin 3) k))) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "generated_single_elem_of_degree_le_p", "problem_id": "20_generated_single_elem_of_degree_le_p", "informal_prefix": "", "formal_statement": "theorem generated_single_elem_of_degree_le_p (p : ‚Ñï) [Fact (Nat.Prime p)]\n    (K L : Type) [Field K] [Field L] [CharP L p] [Algebra K L] [FiniteDimensional K L]\n    (h : Module.rank (IntermediateField.adjoin K ((frobenius L p).range : Set L)) L ‚â§ p) :\n    ‚àÉ (x : L), IntermediateField.adjoin K {x} = ‚ä§ := by\n  sorry", "lean4_code": "import Mathlib\ntheorem generated_single_elem_of_degree_le_p (p : ‚Ñï) [Fact (Nat.Prime p)]\n    (K L : Type) [Field K] [Field L] [CharP L p] [Algebra K L] [FiniteDimensional K L]\n    (h : Module.rank (IntermediateField.adjoin K ((frobenius L p).range : Set L)) L ‚â§ p) :\n    ‚àÉ (x : L), IntermediateField.adjoin K {x} = ‚ä§ := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isNoetherianRing_of_fg_of_isNoetherianRing", "problem_id": "33_isNoetherianRing_of_fg_of_isNoetherianRing", "informal_prefix": "", "formal_statement": "theorem isNoetherianRing_of_fg_of_isNoetherianRing (B : Type) [CommRing B] [IsNoetherianRing B]\n    (A : Subring B) (h : Module.Finite A B) : IsNoetherianRing A := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isNoetherianRing_of_fg_of_isNoetherianRing (B : Type) [CommRing B] [IsNoetherianRing B]\n    (A : Subring B) (h : Module.Finite A B) : IsNoetherianRing A := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "noetherian_of_prime_ideals_fg", "problem_id": "35_noetherian_of_prime_ideals_fg", "informal_prefix": "", "formal_statement": "theorem noetherian_of_prime_ideals_fg (R : Type) [CommRing R]\n    (h_fg : ‚àÄ (p : Ideal R), p.IsPrime ‚Üí p.FG) : IsNoetherianRing R := by\n  sorry", "lean4_code": "import Mathlib\ntheorem noetherian_of_prime_ideals_fg (R : Type) [CommRing R]\n    (h_fg : ‚àÄ (p : Ideal R), p.IsPrime ‚Üí p.FG) : IsNoetherianRing R := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isPrincipalIdealRing_of_associated_or_associated", "problem_id": "1_isPrincipalIdealRing_of_associated_or_associated", "informal_prefix": "/-- Let $R$ be a UFD with two nonassociate prime elements $p$ and $q$ such that every prime\nelement is an associate of either $p$ or $q$.  Prove that $R$ is a PID. -/", "formal_statement": "import Mathlib\n\n/-- Let $R$ be a UFD with two nonassociate prime elements $p$ and $q$ such that every prime\nelement is an associate of either $p$ or $q$.  Prove that $R$ is a PID. -/\ntheorem isPrincipalIdealRing_of_associated_or_associated {R : Type} [CommRing R] [IsDomain R]\n    [UniqueFactorizationMonoid R] {p q : R} (hp : Prime p) (hq : Prime q) (hpq : ¬¨ Associated p q)\n    (h : ‚àÄ {x : R}, Prime x ‚Üí Associated x p ‚à® Associated x q) :\n    IsPrincipalIdealRing R := by\n  sorry", "lean4_code": "import Mathlib\n\n/-- Let $R$ be a UFD with two nonassociate prime elements $p$ and $q$ such that every prime\nelement is an associate of either $p$ or $q$.  Prove that $R$ is a PID. -/\ntheorem isPrincipalIdealRing_of_associated_or_associated {R : Type} [CommRing R] [IsDomain R]\n    [UniqueFactorizationMonoid R] {p q : R} (hp : Prime p) (hq : Prime q) (hpq : ¬¨ Associated p q)\n    (h : ‚àÄ {x : R}, Prime x ‚Üí Associated x p ‚à® Associated x q) :\n    IsPrincipalIdealRing R := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "zeroSet", "problem_id": "94_zeroSet", "informal_prefix": "/--\nLet $k$ be field, $\\mathrm{char}\\ k=0$, $ A $ be a finite-type $k$-algebra, $f: A \\to A$ be an \\'etale endomorphsim, $\\varphi: A \\to k$, $I \\subset A$ be a ideal.\nIf $A$ is a domain, then $$\\left\\lbrace  n \\in \\mathbb{N} \\mid \\left. \\varphi \\circ f^n \\right|_I = 0 \\right\\rbrace $$ is either finite or contains an arithmetic progression with a positive common difference. -/", "formal_statement": "def zeroSet : Set ‚Ñï := {n | ‚àÄ x : I, (œï.comp (f ^ n)) (x : A) = 0}\n\n/--\nLet $k$ be field, $\\mathrm{char}\\ k=0$, $ A $ be a finite-type $k$-algebra, $f: A \\to A$ be an \\'etale endomorphsim, $\\varphi: A \\to k$, $I \\subset A$ be a ideal.\nIf $A$ is a domain, then $$\\left\\lbrace  n \\in \\mathbb{N} \\mid \\left. \\varphi \\circ f^n \\right|_I = 0 \\right\\rbrace $$ is either finite or contains an arithmetic progression with a positive common difference. -/", "lean4_code": "import Mathlib\n/--\nLet $k$ be field, $\\mathrm{char}\\ k=0$, $ A $ be a finite-type $k$-algebra, $f: A \\to A$ be an \\'etale endomorphsim, $\\varphi: A \\to k$, $I \\subset A$ be a ideal.\nIf $A$ is a domain, then $$\\left\\lbrace  n \\in \\mathbb{N} \\mid \\left. \\varphi \\circ f^n \\right|_I = 0 \\right\\rbrace $$ is either finite or contains an arithmetic progression with a positive common difference. -/\ndef zeroSet : Set ‚Ñï := {n | ‚àÄ x : I, (œï.comp (f ^ n)) (x : A) = 0}\n\n/--\nLet $k$ be field, $\\mathrm{char}\\ k=0$, $ A $ be a finite-type $k$-algebra, $f: A \\to A$ be an \\'etale endomorphsim, $\\varphi: A \\to k$, $I \\subset A$ be a ideal.\nIf $A$ is a domain, then $$\\left\\lbrace  n \\in \\mathbb{N} \\mid \\left. \\varphi \\circ f^n \\right|_I = 0 \\right\\rbrace $$ is either finite or contains an arithmetic progression with a positive common difference. -/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "zeroSet_finite_or_contain_arithmetic_progression", "problem_id": "94_zeroSet_finite_or_contain_arithmetic_progression", "informal_prefix": "", "formal_statement": "theorem zeroSet_finite_or_contain_arithmetic_progression (hf : f.FormallyEtale) :\n    (zeroSet f œï I).Finite ‚à® ‚àÉ (d : ‚Ñï+) (a : ‚Ñï), ‚àÄ n : ‚Ñï, a + d * n ‚àà zeroSet f œï I := by\n  sorry", "lean4_code": "import Mathlib\ntheorem zeroSet_finite_or_contain_arithmetic_progression (hf : f.FormallyEtale) :\n    (zeroSet f œï I).Finite ‚à® ‚àÉ (d : ‚Ñï+) (a : ‚Ñï), ‚àÄ n : ‚Ñï, a + d * n ‚àà zeroSet f œï I := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsRadicalExtension", "problem_id": "18_IsRadicalExtension", "informal_prefix": "/--\nAn algebra is said to be a radical tower over the base ring if it can be written as\ncomposition of radical extensions.\n-/", "formal_statement": "def IsRadicalExtension (E F : Type) [CommRing E] [CommRing F] [Algebra E F] : Prop :=\n    ‚àÉ (x : F), Algebra.adjoin E {x} = ‚ä§ ‚àß (‚àÉ (n : ‚Ñï) (e : E), n ‚â• 1 ‚àß x ^ n - (algebraMap E F) e = 0)\n\n/--\nAn algebra is said to be a radical tower over the base ring if it can be written as\ncomposition of radical extensions.\n-/\ninductive IsRadicalTower : ‚àÄ (E : Type) (F : Type) [CommRing E] [CommRing F] [Algebra E F], Prop\n  | of_isRadicalExtension (E : Type) (F : Type)\n      [CommRing E] [CommRing F] [Algebra E F] : IsRadicalExtension E F ‚Üí IsRadicalTower E F\n  | of_composition (E : Type) (F : Type) [CommRing E] [CommRing F] [Algebra E F] (F' : Subalgebra E F) :\n      IsRadicalExtension F' F ‚Üí IsRadicalTower E F' ‚Üí IsRadicalTower E F\n\n/--\nLet \\( E \\) be a subfield of \\( \\mathbb{R} \\) and let \\( K/E \\) be a finite Galois extension of odd degree \\( > 1 \\).\nProve that \\( K \\) cannot be \\( E \\)-embedded into a radical tower that is a subfield of \\( \\mathbb{R} \\).\n-/", "lean4_code": "import Mathlib\n/--\nAn algebra is said to be a radical tower over the base ring if it can be written as\ncomposition of radical extensions.\n-/\ndef IsRadicalExtension (E F : Type) [CommRing E] [CommRing F] [Algebra E F] : Prop :=\n    ‚àÉ (x : F), Algebra.adjoin E {x} = ‚ä§ ‚àß (‚àÉ (n : ‚Ñï) (e : E), n ‚â• 1 ‚àß x ^ n - (algebraMap E F) e = 0)\n\n/--\nAn algebra is said to be a radical tower over the base ring if it can be written as\ncomposition of radical extensions.\n-/\ninductive IsRadicalTower : ‚àÄ (E : Type) (F : Type) [CommRing E] [CommRing F] [Algebra E F], Prop\n  | of_isRadicalExtension (E : Type) (F : Type)\n      [CommRing E] [CommRing F] [Algebra E F] : IsRadicalExtension E F ‚Üí IsRadicalTower E F\n  | of_composition (E : Type) (F : Type) [CommRing E] [CommRing F] [Algebra E F] (F' : Subalgebra E F) :\n      IsRadicalExtension F' F ‚Üí IsRadicalTower E F' ‚Üí IsRadicalTower E F\n\n/--\nLet \\( E \\) be a subfield of \\( \\mathbb{R} \\) and let \\( K/E \\) be a finite Galois extension of odd degree \\( > 1 \\).\nProve that \\( K \\) cannot be \\( E \\)-embedded into a radical tower that is a subfield of \\( \\mathbb{R} \\).\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isEmpty_embedding_intermediateField_of_odd_degree_galois", "problem_id": "18_isEmpty_embedding_intermediateField_of_odd_degree_galois", "informal_prefix": "", "formal_statement": "theorem isEmpty_embedding_intermediateField_of_odd_degree_galois (E : Subfield ‚Ñù) (K : Type)\n    [Field K] [Algebra E K] [IsGalois E K] (n : ‚Ñï) (h_odd : Odd n) (hn : n > 1) (h_deg_eq : Module.rank E K = n)\n    (K' : IntermediateField E ‚Ñù) (h_radical : IsRadicalTower E K') :\n    IsEmpty (K ‚Üí‚Çê[E] K') := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isEmpty_embedding_intermediateField_of_odd_degree_galois (E : Subfield ‚Ñù) (K : Type)\n    [Field K] [Algebra E K] [IsGalois E K] (n : ‚Ñï) (h_odd : Odd n) (hn : n > 1) (h_deg_eq : Module.rank E K = n)\n    (K' : IntermediateField E ‚Ñù) (h_radical : IsRadicalTower E K') :\n    IsEmpty (K ‚Üí‚Çê[E] K') := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_minimalPrime_map_zero", "problem_id": "70_exists_minimalPrime_map_zero", "informal_prefix": "", "formal_statement": "theorem exists_minimalPrime_map_zero (R S : Type) [CommRing R] [IsDomain R] [IsNoetherianRing R]\n    [CommRing S] [IsNoetherianRing S] [IsLocalRing S] [Algebra R S] [NoZeroSMulDivisors R S] :\n    ‚àÉ (p : minimalPrimes S), Ideal.comap (algebraMap R S) p.1 = ‚ä• := by\n  sorry", "lean4_code": "import Mathlib\ntheorem exists_minimalPrime_map_zero (R S : Type) [CommRing R] [IsDomain R] [IsNoetherianRing R]\n    [CommRing S] [IsNoetherianRing S] [IsLocalRing S] [Algebra R S] [NoZeroSMulDivisors R S] :\n    ‚àÉ (p : minimalPrimes S), Ideal.comap (algebraMap R S) p.1 = ‚ä• := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "moduleDepth", "problem_id": "78_moduleDepth", "informal_prefix": "/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/", "formal_statement": "def moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\n\n/--\nLet $A$ be a local Cohen‚ÄìMacaulay (CM) ring that is a quotient of a regular local ring.\nIf $A$ is a UFD, then $A$ is Gorenstein.\n-/", "lean4_code": "import Mathlib\nopen IsLocalRing ModuleCat CategoryTheory\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\ndef moduleDepth (N M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  sSup {n : ‚Ñï‚àû | ‚àÄ i : ‚Ñï, i < n ‚Üí Subsingleton (CategoryTheory.Abelian.Ext.{0} N M i)}\n\nnoncomputable def Ideal.depth (I : Ideal R) (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  moduleDepth (ModuleCat.of R (R ‚ß∏ I)) M\n\nnoncomputable def IsLocalRing.depth [IsLocalRing R] (M : ModuleCat.{0} R) : ‚Ñï‚àû :=\n  (IsLocalRing.maximalIdeal R).depth M\n\nvariable (R)\n\nclass IsCohenMacaulayLocalRing : Prop extends IsLocalRing R where\n  depth_eq_dim : ringKrullDim R = IsLocalRing.depth (ModuleCat.of R R)\n\nclass IsCohenMacaulayRing : Prop where\n  CM_localize : ‚àÄ p : Ideal R, ‚àÄ (_ : p.IsPrime), IsCohenMacaulayLocalRing (Localization.AtPrime p)\n\nend\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\n\n/--\nLet $A$ be a local Cohen‚ÄìMacaulay (CM) ring that is a quotient of a regular local ring.\nIf $A$ is a UFD, then $A$ is Gorenstein.\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "not_finiteType_inf_algebraMap_range", "problem_id": "90_not_finiteType_inf_algebraMap_range", "informal_prefix": "", "formal_statement": "theorem not_finiteType_inf_algebraMap_range (k : Type) [Field k] :\n    ‚àÉ (n : ‚Ñï) (K : IntermediateField k (FractionRing (MvPolynomial (Fin n) k))),\n    ¬¨ Algebra.FiniteType k (K.toSubalgebra ‚äì (Algebra.algHom k (MvPolynomial (Fin n) k)\n    (FractionRing (MvPolynomial (Fin n) k))).range :\n    Subalgebra k (FractionRing (MvPolynomial (Fin n) k))) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem not_finiteType_inf_algebraMap_range (k : Type) [Field k] :\n    ‚àÉ (n : ‚Ñï) (K : IntermediateField k (FractionRing (MvPolynomial (Fin n) k))),\n    ¬¨ Algebra.FiniteType k (K.toSubalgebra ‚äì (Algebra.algHom k (MvPolynomial (Fin n) k)\n    (FractionRing (MvPolynomial (Fin n) k))).range :\n    Subalgebra k (FractionRing (MvPolynomial (Fin n) k))) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "countable_index_of_maximal_subfield_sqrt_2_nmem", "problem_id": "17_countable_index_of_maximal_subfield_sqrt_2_nmem", "informal_prefix": "", "formal_statement": "theorem countable_index_of_maximal_subfield_sqrt_2_nmem\n    (K : Subfield ‚ÑÇ) (h_nmem : (Real.sqrt 2 : ‚ÑÇ) ‚àâ K)\n    (h : ‚àÄ (L : Subfield ‚ÑÇ), K ‚â§ L ‚Üí (Real.sqrt 2 : ‚ÑÇ) ‚àâ L ‚Üí K = L) :\n    Module.rank K ‚ÑÇ = Cardinal.aleph0 := by\n  sorry", "lean4_code": "import Mathlib\ntheorem countable_index_of_maximal_subfield_sqrt_2_nmem\n    (K : Subfield ‚ÑÇ) (h_nmem : (Real.sqrt 2 : ‚ÑÇ) ‚àâ K)\n    (h : ‚àÄ (L : Subfield ‚ÑÇ), K ‚â§ L ‚Üí (Real.sqrt 2 : ‚ÑÇ) ‚àâ L ‚Üí K = L) :\n    Module.rank K ‚ÑÇ = Cardinal.aleph0 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_leftCoset_rightCoset_representative", "problem_id": "3_exists_leftCoset_rightCoset_representative", "informal_prefix": "", "formal_statement": "theorem exists_leftCoset_rightCoset_representative\n    (G : Type) [Group G] (H : Subgroup G) [H.FiniteIndex] :\n    ‚àÉ S : Set G, Subgroup.IsComplement S H ‚àß Subgroup.IsComplement H S := by\n  sorry", "lean4_code": "import Mathlib\ntheorem exists_leftCoset_rightCoset_representative\n    (G : Type) [Group G] (H : Subgroup G) [H.FiniteIndex] :\n    ‚àÉ S : Set G, Subgroup.IsComplement S H ‚àß Subgroup.IsComplement H S := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_maximal_ideal_not_in_finite_order", "problem_id": "98_exists_maximal_ideal_not_in_finite_order", "informal_prefix": "/--\nIf $K$ be a number field, $A$ be a finite-type $K$-algebra, $f : A \\to A$ be an endomorphism.\nIf $A$ is a domain and $f$ is not of finite order, then there exists a maximal ideal $m \\subset A$\nsuch that for all $n \\in \\mathbb{N}_+$, $f^{-n}(m) \\ne m$.\n-/", "formal_statement": "import Mathlib\n\n/--\nIf $K$ be a number field, $A$ be a finite-type $K$-algebra, $f : A \\to A$ be an endomorphism.\nIf $A$ is a domain and $f$ is not of finite order, then there exists a maximal ideal $m \\subset A$\nsuch that for all $n \\in \\mathbb{N}_+$, $f^{-n}(m) \\ne m$.\n-/\ntheorem exists_maximal_ideal_not_in_finite_order {K A : Type} [Field K] [NumberField K] [CommRing A]\n    [IsDomain A] [Algebra K A] [Algebra.FiniteType K A] {f : A ‚Üí‚Çê[K] A} (hf : ‚àÄ n > 0, f ^ n ‚â† 1) :\n    ‚àÉ m : Ideal A, m.IsMaximal ‚àß ‚àÄ n > 0, m.comap (f ^ n) ‚â† m := by\n  sorry", "lean4_code": "import Mathlib\n\n/--\nIf $K$ be a number field, $A$ be a finite-type $K$-algebra, $f : A \\to A$ be an endomorphism.\nIf $A$ is a domain and $f$ is not of finite order, then there exists a maximal ideal $m \\subset A$\nsuch that for all $n \\in \\mathbb{N}_+$, $f^{-n}(m) \\ne m$.\n-/\ntheorem exists_maximal_ideal_not_in_finite_order {K A : Type} [Field K] [NumberField K] [CommRing A]\n    [IsDomain A] [Algebra K A] [Algebra.FiniteType K A] {f : A ‚Üí‚Çê[K] A} (hf : ‚àÄ n > 0, f ^ n ‚â† 1) :\n    ‚àÉ m : Ideal A, m.IsMaximal ‚àß ‚àÄ n > 0, m.comap (f ^ n) ‚â† m := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isGalois_and_rank_eq_of_isPrimitiveRoot_sq", "problem_id": "27_isGalois_and_rank_eq_of_isPrimitiveRoot_sq", "informal_prefix": "", "formal_statement": "theorem isGalois_and_rank_eq_of_isPrimitiveRoot_sq (p : ‚Ñï) (hp : p.Prime) {K : Type} [Field K]\n    [NumberField K] {Œ∂ : K} (h : IsPrimitiveRoot Œ∂ (p^2))\n    {L : IntermediateField K (AlgebraicClosure K)} [IsGalois K L]\n    (hdeg : Module.rank K L = p) :\n    ‚àÉ (L' : Type) (_ : Field L') (_ : Algebra K L')\n    (_ : Algebra L L') (_ : IsScalarTower K L L'),\n    IsGalois K L' ‚àß IsGalois L L' ‚àß Module.rank L L' = p := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isGalois_and_rank_eq_of_isPrimitiveRoot_sq (p : ‚Ñï) (hp : p.Prime) {K : Type} [Field K]\n    [NumberField K] {Œ∂ : K} (h : IsPrimitiveRoot Œ∂ (p^2))\n    {L : IntermediateField K (AlgebraicClosure K)} [IsGalois K L]\n    (hdeg : Module.rank K L = p) :\n    ‚àÉ (L' : Type) (_ : Field L') (_ : Algebra K L')\n    (_ : Algebra L L') (_ : IsScalarTower K L L'),\n    IsGalois K L' ‚àß IsGalois L L' ‚àß Module.rank L L' = p := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "f", "problem_id": "95_f", "informal_prefix": "/--\nLet $f : \\mathbb{C}[x, y] \\to \\mathbb{C}[x, y]$, $x \\mapsto p(x) + ay, y \\mapsto x$,\nwhere $a \\in \\mathbb{C}$, $a \\ne 0$, $p(x) \\in \\mathbb{C}[x]$ have degree $>1$, $\\mathfrak{p} \\subset \\mathbb{C}[x, y]$ be a prime ideal.\nIf $\\mathrm{height}\\ \\mathfrak{p} = 1 $, then $f(\\mathfrak{p}) \\ne \\mathfrak{p}$.\n-/", "formal_statement": "def f (a : ‚ÑÇ) (p : ‚ÑÇ[X]): ‚ÑÇ[X][Y] ‚Üí+* ‚ÑÇ[X][Y] :=\n  eval‚ÇÇRingHom (aeval (a ‚Ä¢ Y + C p)).toRingHom (C X)\n\n/--\nLet $f : \\mathbb{C}[x, y] \\to \\mathbb{C}[x, y]$, $x \\mapsto p(x) + ay, y \\mapsto x$,\nwhere $a \\in \\mathbb{C}$, $a \\ne 0$, $p(x) \\in \\mathbb{C}[x]$ have degree $>1$, $\\mathfrak{p} \\subset \\mathbb{C}[x, y]$ be a prime ideal.\nIf $\\mathrm{height}\\ \\mathfrak{p} = 1 $, then $f(\\mathfrak{p}) \\ne \\mathfrak{p}$.\n-/", "lean4_code": "import Mathlib\nopen Polynomial Bivariate\n\n/--\nLet $f : \\mathbb{C}[x, y] \\to \\mathbb{C}[x, y]$, $x \\mapsto p(x) + ay, y \\mapsto x$,\nwhere $a \\in \\mathbb{C}$, $a \\ne 0$, $p(x) \\in \\mathbb{C}[x]$ have degree $>1$, $\\mathfrak{p} \\subset \\mathbb{C}[x, y]$ be a prime ideal.\nIf $\\mathrm{height}\\ \\mathfrak{p} = 1 $, then $f(\\mathfrak{p}) \\ne \\mathfrak{p}$.\n-/\ndef f (a : ‚ÑÇ) (p : ‚ÑÇ[X]): ‚ÑÇ[X][Y] ‚Üí+* ‚ÑÇ[X][Y] :=\n  eval‚ÇÇRingHom (aeval (a ‚Ä¢ Y + C p)).toRingHom (C X)\n\n/--\nLet $f : \\mathbb{C}[x, y] \\to \\mathbb{C}[x, y]$, $x \\mapsto p(x) + ay, y \\mapsto x$,\nwhere $a \\in \\mathbb{C}$, $a \\ne 0$, $p(x) \\in \\mathbb{C}[x]$ have degree $>1$, $\\mathfrak{p} \\subset \\mathbb{C}[x, y]$ be a prime ideal.\nIf $\\mathrm{height}\\ \\mathfrak{p} = 1 $, then $f(\\mathfrak{p}) \\ne \\mathfrak{p}$.\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "p_map_ne_p", "problem_id": "95_p_map_ne_p", "informal_prefix": "", "formal_statement": "theorem p_map_ne_p (p : ‚ÑÇ[X]) (h : p.natDegree > 1) {a : ‚ÑÇ} (ha : a ‚â† 0)\n    (ùî≠ : Ideal ‚ÑÇ[X][Y]) (hùî≠ : ùî≠.IsPrime) (h : ùî≠.height = 1) :\n    ùî≠.map (f a p) ‚â† ùî≠ := by\n  sorry", "lean4_code": "import Mathlib\nopen Polynomial Bivariate\n\ntheorem p_map_ne_p (p : ‚ÑÇ[X]) (h : p.natDegree > 1) {a : ‚ÑÇ} (ha : a ‚â† 0)\n    (ùî≠ : Ideal ‚ÑÇ[X][Y]) (hùî≠ : ùî≠.IsPrime) (h : ùî≠.height = 1) :\n    ùî≠.map (f a p) ‚â† ùî≠ := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "add_one_eq_two_pow_of_sylow_subgroup_not_normal", "problem_id": "4_add_one_eq_two_pow_of_sylow_subgroup_not_normal", "informal_prefix": "", "formal_statement": "theorem add_one_eq_two_pow_of_sylow_subgroup_not_normal (p : ‚Ñï) (h_odd : Odd p) (G : Type)\n    (hp : p.Prime) [Finite G] [Group G] (h_card : Nat.card G = p * (p + 1))\n    (h_sylow : ‚àÄ (H : Sylow p G), ¬¨ H.Normal) : ‚àÉ (n : ‚Ñï), p + 1 = 2 ^ n := by\n  sorry", "lean4_code": "import Mathlib\ntheorem add_one_eq_two_pow_of_sylow_subgroup_not_normal (p : ‚Ñï) (h_odd : Odd p) (G : Type)\n    (hp : p.Prime) [Finite G] [Group G] (h_card : Nat.card G = p * (p + 1))\n    (h_sylow : ‚àÄ (H : Sylow p G), ¬¨ H.Normal) : ‚àÉ (n : ‚Ñï), p + 1 = 2 ^ n := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "not_isomorphic_euclideanDomain", "problem_id": "11_not_isomorphic_euclideanDomain", "informal_prefix": "", "formal_statement": "theorem not_isomorphic_euclideanDomain : IsEmpty <| EuclideanNormNat (((MvPolynomial ‚Ñù (Fin 2)) ‚ß∏ Ideal.span {(.X 0 ^ 2 + .X 1 ^ 2 + .C 1: MvPolynomial ‚Ñù (Fin 2))})) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem not_isomorphic_euclideanDomain : IsEmpty <| EuclideanNormNat (((MvPolynomial ‚Ñù (Fin 2)) ‚ß∏ Ideal.span {(.X 0 ^ 2 + .X 1 ^ 2 + .C 1: MvPolynomial ‚Ñù (Fin 2))})) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isClosed_zpowers_iff_isOfFinOrder", "problem_id": "29_isClosed_zpowers_iff_isOfFinOrder", "informal_prefix": "", "formal_statement": "theorem isClosed_zpowers_iff_isOfFinOrder (K : Type)\n    [Field K] [Algebra ‚Ñö K] [Module.Finite ‚Ñö K] (g : Field.absoluteGaloisGroup K) :\n    IsClosed ((Subgroup.zpowers g) : Set (Field.absoluteGaloisGroup K)) ‚Üî IsOfFinOrder g := by\n  sorry", "lean4_code": "import Mathlib\ntheorem isClosed_zpowers_iff_isOfFinOrder (K : Type)\n    [Field K] [Algebra ‚Ñö K] [Module.Finite ‚Ñö K] (g : Field.absoluteGaloisGroup K) :\n    IsClosed ((Subgroup.zpowers g) : Set (Field.absoluteGaloisGroup K)) ‚Üî IsOfFinOrder g := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "module_flat_iff", "problem_id": "46_module_flat_iff", "informal_prefix": "", "formal_statement": "theorem module_flat_iff (R : Type) [CommRing R] (M : Type) [AddCommGroup M] [Module R M] :\n    Module.Flat R M ‚Üî\n    ‚àÄ P : Type, ‚àÄ (_ : AddCommGroup P), ‚àÄ (_ : Module R P), ‚àÄ f : P ‚Üí‚Çó[R] M, Module.FinitePresentation R P ‚Üí\n      ‚àÉ (F : Type) (_ : AddCommGroup F) (_ : Module R F), Module.Finite R F ‚àß Module.Free R F ‚àß\n      ‚àÉ h : P ‚Üí‚Çó[R] F, ‚àÉ g : F ‚Üí‚Çó[R] M, f = g.comp h := by\n  sorry", "lean4_code": "import Mathlib\ntheorem module_flat_iff (R : Type) [CommRing R] (M : Type) [AddCommGroup M] [Module R M] :\n    Module.Flat R M ‚Üî\n    ‚àÄ P : Type, ‚àÄ (_ : AddCommGroup P), ‚àÄ (_ : Module R P), ‚àÄ f : P ‚Üí‚Çó[R] M, Module.FinitePresentation R P ‚Üí\n      ‚àÉ (F : Type) (_ : AddCommGroup F) (_ : Module R F), Module.Finite R F ‚àß Module.Free R F ‚àß\n      ‚àÉ h : P ‚Üí‚Çó[R] F, ‚àÉ g : F ‚Üí‚Çó[R] M, f = g.comp h := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsCatenary", "problem_id": "76_IsCatenary", "informal_prefix": "/--\nLet $A$ be a Noetherian UFD of dimension $d \\leq 3$. Prove that $A$ is catenary.\n-/", "formal_statement": "def IsCatenary (R : Type) [CommRing R] : Prop :=\n  ‚àÄ p q : PrimeSpectrum R, p ‚â§ q ‚Üí\n  ‚àÉ n : ‚Ñï, ‚àÄ (l : LTSeries (PrimeSpectrum R)), l.head = p ‚Üí l.last = q ‚Üí\n  (‚àÄ l' : LTSeries (PrimeSpectrum R), l'.head = p ‚Üí l'.last = q ‚Üí l.toList <+ l'.toList ‚Üí l' = l) ‚Üí\n  l.toList.length = n\n\n/--\nLet $A$ be a Noetherian UFD of dimension $d \\leq 3$. Prove that $A$ is catenary.\n-/", "lean4_code": "import Mathlib\nopen List\n\n/--\nLet $A$ be a Noetherian UFD of dimension $d \\leq 3$. Prove that $A$ is catenary.\n-/\ndef IsCatenary (R : Type) [CommRing R] : Prop :=\n  ‚àÄ p q : PrimeSpectrum R, p ‚â§ q ‚Üí\n  ‚àÉ n : ‚Ñï, ‚àÄ (l : LTSeries (PrimeSpectrum R)), l.head = p ‚Üí l.last = q ‚Üí\n  (‚àÄ l' : LTSeries (PrimeSpectrum R), l'.head = p ‚Üí l'.last = q ‚Üí l.toList <+ l'.toList ‚Üí l' = l) ‚Üí\n  l.toList.length = n\n\n/--\nLet $A$ be a Noetherian UFD of dimension $d \\leq 3$. Prove that $A$ is catenary.\n-/", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "formallySmooth_of_formallySmooth_quotient", "problem_id": "61_formallySmooth_of_formallySmooth_quotient", "informal_prefix": "", "formal_statement": "theorem formallySmooth_of_formallySmooth_quotient (R S : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Module.Flat R S] (I : Ideal R) (h : I ^ 2 = 0)\n    [Algebra.FormallySmooth (R ‚ß∏ I) (S ‚ß∏ (I.map (algebraMap R S)))] :\n    Algebra.FormallySmooth R S := by\n  sorry", "lean4_code": "import Mathlib\ntheorem formallySmooth_of_formallySmooth_quotient (R S : Type) [CommRing R] [CommRing S]\n    [Algebra R S] [Module.Flat R S] (I : Ideal R) (h : I ^ 2 = 0)\n    [Algebra.FormallySmooth (R ‚ß∏ I) (S ‚ß∏ (I.map (algebraMap R S)))] :\n    Algebra.FormallySmooth R S := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "generated_by_regular_sequence_iff", "problem_id": "81_generated_by_regular_sequence_iff", "informal_prefix": "", "formal_statement": "theorem generated_by_regular_sequence_iff (R : Type) [CommRing R] [IsLocalRing R]\n    [IsNoetherianRing R] (I : Ideal R) (netop : I ‚â† ‚ä§) :\n    ‚àÉ (rs : List R), (RingTheory.Sequence.IsRegular R rs) ‚àß Ideal.ofList rs = I ‚Üî\n    Module.Free (R ‚ß∏ I) I.Cotangent ‚àß\n    (‚àÉ n, CategoryTheory.HasProjectiveDimensionLE (ModuleCat.of R I) n) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem generated_by_regular_sequence_iff (R : Type) [CommRing R] [IsLocalRing R]\n    [IsNoetherianRing R] (I : Ideal R) (netop : I ‚â† ‚ä§) :\n    ‚àÉ (rs : List R), (RingTheory.Sequence.IsRegular R rs) ‚àß Ideal.ofList rs = I ‚Üî\n    Module.Free (R ‚ß∏ I) I.Cotangent ‚àß\n    (‚àÉ n, CategoryTheory.HasProjectiveDimensionLE (ModuleCat.of R I) n) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "exists_directSum_free_free_of_projective", "problem_id": "84_exists_directSum_free_free_of_projective", "informal_prefix": "", "formal_statement": "theorem exists_directSum_free_free_of_projective (R M : Type) [CommRing R] [AddCommGroup M]\n    [Module R M] [Module.Projective R M] : ‚àÉ (N : Type) (_ : AddCommGroup N) (_ : Module R N),\n    Module.Free R N ‚àß Module.Free R (N √ó M) := by\n  sorry", "lean4_code": "import Mathlib\ntheorem exists_directSum_free_free_of_projective (R M : Type) [CommRing R] [AddCommGroup M]\n    [Module R M] [Module.Projective R M] : ‚àÉ (N : Type) (_ : AddCommGroup N) (_ : Module R N),\n    Module.Free R N ‚àß Module.Free R (N √ó M) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "isEmpty_mvPowerSeries_tensor_mvPowerSeries_algEquiv", "problem_id": "67_isEmpty_mvPowerSeries_tensor_mvPowerSeries_algEquiv", "informal_prefix": "/--\nLet $A$ be the ring $k[[x_1, \\dots, x_n]]$, where $k$ is a field, $n \\in \\mathbb{N}$, $n \\ne 0$.\nShow that there is \\textbf{no} isomorphism\n\\[\nA \\otimes_k A \\cong k[[x_1, \\dots, x_n, y_1, \\dots, y_n]].\n\\]\n-/", "formal_statement": "import Mathlib\n\nopen scoped TensorProduct\n\n/--\nLet $A$ be the ring $k[[x_1, \\dots, x_n]]$, where $k$ is a field, $n \\in \\mathbb{N}$, $n \\ne 0$.\nShow that there is \\textbf{no} isomorphism\n\\[\nA \\otimes_k A \\cong k[[x_1, \\dots, x_n, y_1, \\dots, y_n]].\n\\]\n-/\ntheorem isEmpty_mvPowerSeries_tensor_mvPowerSeries_algEquiv\n    {k : Type} [Field k] (n : ‚Ñï) (hn : n ‚â† 0) :\n    IsEmpty ((MvPowerSeries (Fin n) k) ‚äó[k] (MvPowerSeries (Fin n) k) ‚âÉ‚Çê[k]\n    (MvPowerSeries (Fin (n + n)) k)) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen scoped TensorProduct\n\n/--\nLet $A$ be the ring $k[[x_1, \\dots, x_n]]$, where $k$ is a field, $n \\in \\mathbb{N}$, $n \\ne 0$.\nShow that there is \\textbf{no} isomorphism\n\\[\nA \\otimes_k A \\cong k[[x_1, \\dots, x_n, y_1, \\dots, y_n]].\n\\]\n-/\ntheorem isEmpty_mvPowerSeries_tensor_mvPowerSeries_algEquiv\n    {k : Type} [Field k] (n : ‚Ñï) (hn : n ‚â† 0) :\n    IsEmpty ((MvPowerSeries (Fin n) k) ‚äó[k] (MvPowerSeries (Fin n) k) ‚âÉ‚Çê[k]\n    (MvPowerSeries (Fin (n + n)) k)) := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "not_isSimpleGroup_of_card_eq_1785", "problem_id": "7_not_isSimpleGroup_of_card_eq_1785", "informal_prefix": "", "formal_statement": "theorem not_isSimpleGroup_of_card_eq_1785 (G : Type) [Group G]\n    [Finite G] (h_card : Nat.card G = 1785) : ¬¨ IsSimpleGroup G := by\n  sorry", "lean4_code": "import Mathlib\ntheorem not_isSimpleGroup_of_card_eq_1785 (G : Type) [Group G]\n    [Finite G] (h_card : Nat.card G = 1785) : ¬¨ IsSimpleGroup G := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "not_isSimpleGroup_of_card_eq_396", "problem_id": "6_not_isSimpleGroup_of_card_eq_396", "informal_prefix": "", "formal_statement": "theorem not_isSimpleGroup_of_card_eq_396 (G : Type) [Group G]\n    [Finite G] (h_card : Nat.card G = 396) : ¬¨ IsSimpleGroup G := by\n  sorry", "lean4_code": "import Mathlib\ntheorem not_isSimpleGroup_of_card_eq_396 (G : Type) [Group G]\n    [Finite G] (h_card : Nat.card G = 396) : ¬¨ IsSimpleGroup G := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "card_one_or_two_of_finite_closed_subgroup_of_absoluteGaloisGroup", "problem_id": "26_card_one_or_two_of_finite_closed_subgroup_of_absoluteGaloisGroup", "informal_prefix": "", "formal_statement": "theorem card_one_or_two_of_finite_closed_subgroup_of_absoluteGaloisGroup\n    (K : Type) [Field K] [Algebra ‚Ñö K] [Module.Finite ‚Ñö K]\n    (H : Subgroup (Field.absoluteGaloisGroup K))\n    (h_closed : IsClosed (H : Set (Field.absoluteGaloisGroup K)))\n    (h_fin : Finite H) : Nat.card H = 1 ‚à® Nat.card H = 2 := by\n  sorry", "lean4_code": "import Mathlib\ntheorem card_one_or_two_of_finite_closed_subgroup_of_absoluteGaloisGroup\n    (K : Type) [Field K] [Algebra ‚Ñö K] [Module.Finite ‚Ñö K]\n    (H : Subgroup (Field.absoluteGaloisGroup K))\n    (h_closed : IsClosed (H : Set (Field.absoluteGaloisGroup K)))\n    (h_fin : Finite H) : Nat.card H = 1 ‚à® Nat.card H = 2 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "not_isSimpleGroup_of_card_eq_336", "problem_id": "89_not_isSimpleGroup_of_card_eq_336", "informal_prefix": "", "formal_statement": "theorem not_isSimpleGroup_of_card_eq_336 (G : Type) [Group G]\n    [Finite G] (h_card : Nat.card G = 336) : ¬¨ IsSimpleGroup G := by\n  sorry", "lean4_code": "import Mathlib\ntheorem not_isSimpleGroup_of_card_eq_336 (G : Type) [Group G]\n    [Finite G] (h_card : Nat.card G = 336) : ¬¨ IsSimpleGroup G := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "IsLocalRing", "problem_id": "79_IsLocalRing", "informal_prefix": "/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/", "formal_statement": "import Mathlib\n\nopen IsLocalRing ModuleCat CategoryTheory\n\ninstance (R : Type) [CommRing R] : CategoryTheory.HasExt.{0} (ModuleCat.{0} R) :=\n  CategoryTheory.hasExt_of_enoughProjectives.{0} (ModuleCat.{0} R)\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\n\n/-- A Noetherian local ring $A$ is a local complete intersection if every surjection of local rings\n  $R \\to \\widehat{A}$ with $R$ a regular local ring, the kernel of $R \\to \\hat{A}$ is generated by a\n  regular sequence. -/\n@[stacks 09Q3]\nclass IsLocalCompleteIntersectionRing (A : Type) [CommRing A] : Prop extends\n    IsLocalRing A, IsNoetherianRing A where\n  out (R : Type) [CommRing R] [IsRegularLocalRing R]\n    (f : R ‚Üí+* (AdicCompletion (maximalIdeal A) A)) (_ : IsLocalHom f) (_ : Function.Surjective f) :\n      ‚àÉ (rs : List R), RingTheory.Sequence.IsRegular R rs ‚àß RingHom.ker f = Ideal.ofList rs\n\n/--\nLet $B$ be a regular local ring and $I \\subset B$ an ideal such that\n$B/I$ is Gorenstein but not a local complete intersection.\nShow that $I$ cannot have height $0$ or $1$.\n-/\ntheorem IsLocalRing.not_isCompleteIntersection.height_not_zero_and_not_one (B : Type) [CommRing B]\n    [IsRegularLocalRing B] (I : Ideal B) [IsGorensteinRing (B ‚ß∏ I)]\n    (hc : ¬¨ IsLocalCompleteIntersectionRing (B ‚ß∏ I)) : I.height ‚â† 0 ‚àß I.height ‚â† 1 := by\n  sorry", "lean4_code": "import Mathlib\n\nopen IsLocalRing ModuleCat CategoryTheory\n\ninstance (R : Type) [CommRing R] : CategoryTheory.HasExt.{0} (ModuleCat.{0} R) :=\n  CategoryTheory.hasExt_of_enoughProjectives.{0} (ModuleCat.{0} R)\n\n/-- A commutative local noetherian ring $R$ is regular if $\\dim m/m^2 = \\dim R$. -/\nclass IsRegularLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  reg : Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R\n\n/-- A Noetherian local ring $R$ is a Gorenstein ring if $\\mathrm{inj}.\\dim_R R < +\\infty$. -/\nclass IsGorensteinLocalRing (R : Type) [CommRing R] : Prop extends\n    IsLocalRing R, IsNoetherianRing R where\n  injDim_le_infity :\n    ‚àÉ n : ‚Ñï, ‚àÄ i : ‚Ñï, n ‚â§ i ‚Üí\n    Subsingleton (Abelian.Ext.{0} (of.{0} R (ResidueField R)) (of.{0} R R) i)\n\n/-- A Noetherian ring is a Gorenstein ring if its localization at every maximal ideal is a\n  Gorenstein local ring. -/\nclass IsGorensteinRing (R : Type) [CommRing R] : Prop extends IsNoetherianRing R where\n  localization_maximal_isGorensteinLocalRing :\n    ‚àÄ m : Ideal R, (_ : m.IsMaximal) ‚Üí IsGorensteinLocalRing (Localization.AtPrime m)\n\n/-- A Noetherian local ring $A$ is a local complete intersection if every surjection of local rings\n  $R \\to \\widehat{A}$ with $R$ a regular local ring, the kernel of $R \\to \\hat{A}$ is generated by a\n  regular sequence. -/\n@[stacks 09Q3]\nclass IsLocalCompleteIntersectionRing (A : Type) [CommRing A] : Prop extends\n    IsLocalRing A, IsNoetherianRing A where\n  out (R : Type) [CommRing R] [IsRegularLocalRing R]\n    (f : R ‚Üí+* (AdicCompletion (maximalIdeal A) A)) (_ : IsLocalHom f) (_ : Function.Surjective f) :\n      ‚àÉ (rs : List R), RingTheory.Sequence.IsRegular R rs ‚àß RingHom.ker f = Ideal.ofList rs\n\n/--\nLet $B$ be a regular local ring and $I \\subset B$ an ideal such that\n$B/I$ is Gorenstein but not a local complete intersection.\nShow that $I$ cannot have height $0$ or $1$.\n-/\ntheorem IsLocalRing.not_isCompleteIntersection.height_not_zero_and_not_one (B : Type) [CommRing B]\n    [IsRegularLocalRing B] (I : Ideal B) [IsGorensteinRing (B ‚ß∏ I)]\n    (hc : ¬¨ IsLocalCompleteIntersectionRing (B ‚ß∏ I)) : I.height ‚â† 0 ‚àß I.height ‚â† 1 := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "finite_primes_lies_over_of_finite_extension", "problem_id": "39_finite_primes_lies_over_of_finite_extension", "informal_prefix": "", "formal_statement": "theorem finite_primes_lies_over_of_finite_extension (R : Type) [CommRing R] [IsDomain R]\n    [IsNoetherianRing R] [IsIntegrallyClosed R] (L : Type) [Field L] [Algebra R L]\n    [Algebra (FractionRing R) L] [IsScalarTower R (FractionRing R) L]\n    [FiniteDimensional (FractionRing R) L] (p : Ideal R) [p.IsPrime] :\n    (p.primesOver (integralClosure R L)).Finite := by\n  sorry", "lean4_code": "import Mathlib\ntheorem finite_primes_lies_over_of_finite_extension (R : Type) [CommRing R] [IsDomain R]\n    [IsNoetherianRing R] [IsIntegrallyClosed R] (L : Type) [Field L] [Algebra R L]\n    [Algebra (FractionRing R) L] [IsScalarTower R (FractionRing R) L]\n    [FiniteDimensional (FractionRing R) L] (p : Ideal R) [p.IsPrime] :\n    (p.primesOver (integralClosure R L)).Finite := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
{"name": "infinite_intermediate_primes", "problem_id": "77_infinite_intermediate_primes", "informal_prefix": "", "formal_statement": "theorem infinite_intermediate_primes (R : Type) [CommRing R] (P Q : Ideal R) (le : P ‚â§ Q)\n    [P.IsPrime] [Q.IsPrime] (h d : ‚Ñï) (lt : 1 < d) (ht1 : P.height = h)\n    (ht2 : (Q.map (Ideal.Quotient.mk P)).height = d) :\n    {P' : Ideal R | P ‚â§ P' ‚àß P' ‚â§ Q ‚àß P'.IsPrime ‚àß P'.height = h + 1 ‚àß\n      (Q.map (Ideal.Quotient.mk P')).height = d - 1}.Infinite := by\n  sorry", "lean4_code": "import Mathlib\ntheorem infinite_intermediate_primes (R : Type) [CommRing R] (P Q : Ideal R) (le : P ‚â§ Q)\n    [P.IsPrime] [Q.IsPrime] (h d : ‚Ñï) (lt : 1 < d) (ht1 : P.height = h)\n    (ht2 : (Q.map (Ideal.Quotient.mk P)).height = d) :\n    {P' : Ideal R | P ‚â§ P' ‚àß P' ‚â§ Q ‚àß P'.IsPrime ‚àß P'.height = h + 1 ‚àß\n      (Q.map (Ideal.Quotient.mk P')).height = d - 1}.Infinite := by\n  sorry", "split": "test", "difficulty": "X", "dataset": "FATE"}
