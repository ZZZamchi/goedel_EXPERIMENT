{"name": "functor_hasLeftAdjoint_iff_structuredArrow_hasInitial", "problem_id": "S_0019_functor_hasLeftAdjoint_iff_structuredArrow_hasInitial", "informal_prefix": "", "formal_statement": "theorem functor_hasLeftAdjoint_iff_structuredArrow_hasInitial\n    (G : D ‚•§ C) :\n    G.IsRightAdjoint ‚Üî ‚àÄ c : C, HasInitial (StructuredArrow c G) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem functor_hasLeftAdjoint_iff_structuredArrow_hasInitial\n    (G : D ‚•§ C) :\n    G.IsRightAdjoint ‚Üî ‚àÄ c : C, HasInitial (StructuredArrow c G) := by\n  sorry", "split": "test"}
{"name": "hasColimits_of_reflective", "problem_id": "S_0048_hasColimits_of_reflective", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C] {D : Type u} [Category.{v} D]\n\n\ntheorem hasColimits_of_reflective (i : C ‚•§ D) [Reflective i] [HasColimits D] :\n    HasColimits C := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C] {D : Type u} [Category.{v} D]\n\n\ntheorem hasColimits_of_reflective (i : C ‚•§ D) [Reflective i] [HasColimits D] :\n    HasColimits C := by\n  sorry", "split": "test"}
{"name": "hom_rightExact_iff_preserves_epi", "problem_id": "S_0086_hom_rightExact_iff_preserves_epi", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits Opposite\n\nvariable {A : Type u} [Category.{v} A] [Abelian A]\n\ntheorem hom_rightExact_iff_preserves_epi (P : A) :\n    PreservesFiniteColimits (preadditiveCoyoneda.obj (op P)) ‚Üî \n    Functor.PreservesEpimorphisms (preadditiveCoyoneda.obj (op P)) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits Opposite\n\nvariable {A : Type u} [Category.{v} A] [Abelian A]\n\ntheorem hom_rightExact_iff_preserves_epi (P : A) :\n    PreservesFiniteColimits (preadditiveCoyoneda.obj (op P)) ‚Üî \n    Functor.PreservesEpimorphisms (preadditiveCoyoneda.obj (op P)) := by\n  sorry", "split": "test"}
{"name": "no_equiv_between_Set_and_op", "problem_id": "S_0047_no_equiv_between_Set_and_op", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\ntheorem no_equiv_between_Set_and_op : ¬¨ Nonempty (Equivalence (Type u) (Type u)·µí·µñ) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\ntheorem no_equiv_between_Set_and_op : ¬¨ Nonempty (Equivalence (Type u) (Type u)·µí·µñ) := by\n  sorry", "split": "test"}
{"name": "not_reflective_and_coreflective", "problem_id": "S_0031_not_reflective_and_coreflective", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\ntheorem not_reflective_and_coreflective (P : ObjectProperty (Type u))\n    (h : P.IsClosedUnderIsomorphisms) (hproper : ‚àÉ X : Type u, ¬¨ P X) :\n    IsEmpty (Reflective P.Œπ) ‚à® IsEmpty (Coreflective P.Œπ) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\ntheorem not_reflective_and_coreflective (P : ObjectProperty (Type u))\n    (h : P.IsClosedUnderIsomorphisms) (hproper : ‚àÉ X : Type u, ¬¨ P X) :\n    IsEmpty (Reflective P.Œπ) ‚à® IsEmpty (Coreflective P.Œπ) := by\n  sorry", "split": "test"}
{"name": "freeProdGrp_iso_coprod", "problem_id": "S_0008_freeProdGrp_iso_coprod", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nuniverse u\nvariable {G H : Grp.{u}}\n\n\ntheorem freeProdGrp_iso_coprod [HasBinaryCoproduct G H] :\n     Nonempty (Monoid.Coprod G H ‚âÖ coprod G H) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nuniverse u\nvariable {G H : Grp.{u}}\n\n\ntheorem freeProdGrp_iso_coprod [HasBinaryCoproduct G H] :\n     Nonempty (Monoid.Coprod G H ‚âÖ coprod G H) := by\n  sorry", "split": "test"}
{"name": "CompHausConcrete", "problem_id": "S_0011_CompHausConcrete", "informal_prefix": "", "formal_statement": "def CompHausConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := CompHaus.{u}\n  U := forget CompHaus}", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef CompHausConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := CompHaus.{u}\n  U := forget CompHaus}", "split": "test"}
{"name": "CompHaus_Has_EnoughInj", "problem_id": "S_0011_CompHaus_Has_EnoughInj", "informal_prefix": "", "formal_statement": "theorem CompHaus_Has_EnoughInj :AHS.HasEnoughInj (C:= CompHausConcrete) := by\n  sorry\n\nend CAT_statement_S_0011", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem CompHaus_Has_EnoughInj :AHS.HasEnoughInj (C:= CompHausConcrete) := by\n  sorry\n\nend CAT_statement_S_0011", "split": "test"}
{"name": "filteredColimitsCommuteWithFiniteLimits", "problem_id": "S_0044_filteredColimitsCommuteWithFiniteLimits", "informal_prefix": "", "formal_statement": "theorem filteredColimitsCommuteWithFiniteLimits :\n  Nonempty (colimit (limit F) ‚âÖ limit (colimit F.flip)) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem filteredColimitsCommuteWithFiniteLimits :\n  Nonempty (colimit (limit F) ‚âÖ limit (colimit F.flip)) := by\n  sorry", "split": "test"}
{"name": "forget_Grp_createsLimits_but_not_coproducts", "problem_id": "S_0055_forget_Grp_createsLimits_but_not_coproducts", "informal_prefix": "", "formal_statement": "theorem forget_Grp_createsLimits_but_not_coproducts : \n    Nonempty (CreatesLimits (forget Grp.{u})) ‚àß \n    ¬¨ Nonempty (PreservesColimitsOfShape (Discrete Bool) (forget Grp.{u})) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem forget_Grp_createsLimits_but_not_coproducts : \n    Nonempty (CreatesLimits (forget Grp.{u})) ‚àß \n    ¬¨ Nonempty (PreservesColimitsOfShape (Discrete Bool) (forget Grp.{u})) := by\n  sorry", "split": "test"}
{"name": "forget_Ab_createsLimits_but_not_coproducts", "problem_id": "S_0055_forget_Ab_createsLimits_but_not_coproducts", "informal_prefix": "", "formal_statement": "theorem forget_Ab_createsLimits_but_not_coproducts : \n    Nonempty (CreatesLimits (forget Ab.{u})) ‚àß \n    ¬¨ Nonempty (PreservesColimitsOfShape (Discrete Bool) (forget Ab.{u})) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem forget_Ab_createsLimits_but_not_coproducts : \n    Nonempty (CreatesLimits (forget Ab.{u})) ‚àß \n    ¬¨ Nonempty (PreservesColimitsOfShape (Discrete Bool) (forget Ab.{u})) := by\n  sorry", "split": "test"}
{"name": "F", "problem_id": "S_0067_F", "informal_prefix": "", "formal_statement": "def F : Nat·µí·µñ ‚•§ RingCat :=\n  {\n    obj := fun ‚ü®n‚ü© => RingCat.of ((k[X] ‚ß∏ Ideal.span {(X ^ n : k[X])}))\n    map := fun {A B} f => match A, B with\n      | ‚ü®n‚ü©, ‚ü®m‚ü© => match f with\n        | ‚ü®‚ü®‚ü®(f : m ‚â§ n)‚ü©‚ü©‚ü© =>\n          RingCat.ofHom (Ideal.Quotient.factor (Ideal.span_singleton_le_span_singleton.mpr (pow_dvd_pow X f)))\n  }", "lean4_code": "import Mathlib\nopen CategoryTheory Polynomial Limits\n\ndef F : Nat·µí·µñ ‚•§ RingCat :=\n  {\n    obj := fun ‚ü®n‚ü© => RingCat.of ((k[X] ‚ß∏ Ideal.span {(X ^ n : k[X])}))\n    map := fun {A B} f => match A, B with\n      | ‚ü®n‚ü©, ‚ü®m‚ü© => match f with\n        | ‚ü®‚ü®‚ü®(f : m ‚â§ n)‚ü©‚ü©‚ü© =>\n          RingCat.ofHom (Ideal.Quotient.factor (Ideal.span_singleton_le_span_singleton.mpr (pow_dvd_pow X f)))\n  }", "split": "test"}
{"name": "truncQuot", "problem_id": "S_0067_truncQuot", "informal_prefix": "", "formal_statement": "def truncQuot (n : ‚Ñï) : PowerSeries k ‚Üí+* RingCat.of ((k[X] ‚ß∏ Ideal.span {(X ^ n : k[X])})) where\n  toFun := fun x => PowerSeries.trunc n x\n  map_zero' := by simp\n  map_one' := by\n    match n with\n    | 0 => rw [show X^0 = 1 by simp, Ideal.span_singleton_one]\n           simp [Ideal.Quotient.zero_eq_one_iff]\n    | n + 1 => simp\n  map_add' := by simp\n  map_mul' := fun x y => by\n    rw [‚Üê PowerSeries.trunc_trunc_mul_trunc, ‚Üê coe_mul, ‚Üê (Ideal.Quotient.mk _).map_mul, quotCommTrunc k _]\n\nnoncomputable def cone_F : Cone (F k) :=\n  {\n    pt := RingCat.of (PowerSeries k)\n    œÄ := {\n      app := fun ‚ü®n‚ü© => RingCat.ofHom (truncQuot k n)\n      naturality := by\n        rintro ‚ü®n‚ü© ‚ü®m‚ü© ‚ü®‚ü®‚ü®(l : m ‚â§ n)‚ü©‚ü©‚ü©\n        ext (x : PowerSeries k)\n        simp [F, truncQuot, ‚Üê PowerSeries.trunc_trunc_of_le x l, quotCommTrunc k]\n    }\n  }", "lean4_code": "import Mathlib\nopen CategoryTheory Polynomial Limits\n\ndef truncQuot (n : ‚Ñï) : PowerSeries k ‚Üí+* RingCat.of ((k[X] ‚ß∏ Ideal.span {(X ^ n : k[X])})) where\n  toFun := fun x => PowerSeries.trunc n x\n  map_zero' := by simp\n  map_one' := by\n    match n with\n    | 0 => rw [show X^0 = 1 by simp, Ideal.span_singleton_one]\n           simp [Ideal.Quotient.zero_eq_one_iff]\n    | n + 1 => simp\n  map_add' := by simp\n  map_mul' := fun x y => by\n    rw [‚Üê PowerSeries.trunc_trunc_mul_trunc, ‚Üê coe_mul, ‚Üê (Ideal.Quotient.mk _).map_mul, quotCommTrunc k _]\n\nnoncomputable def cone_F : Cone (F k) :=\n  {\n    pt := RingCat.of (PowerSeries k)\n    œÄ := {\n      app := fun ‚ü®n‚ü© => RingCat.ofHom (truncQuot k n)\n      naturality := by\n        rintro ‚ü®n‚ü© ‚ü®m‚ü© ‚ü®‚ü®‚ü®(l : m ‚â§ n)‚ü©‚ü©‚ü©\n        ext (x : PowerSeries k)\n        simp [F, truncQuot, ‚Üê PowerSeries.trunc_trunc_of_le x l, quotCommTrunc k]\n    }\n  }", "split": "test"}
{"name": "power_series_islimit", "problem_id": "S_0067_power_series_islimit", "informal_prefix": "", "formal_statement": "theorem power_series_islimit : Nonempty (IsLimit (cone_F k)) := by\n  sorry\n\nend CAT_statement_S_0067", "lean4_code": "import Mathlib\nopen CategoryTheory Polynomial Limits\n\ntheorem power_series_islimit : Nonempty (IsLimit (cone_F k)) := by\n  sorry\n\nend CAT_statement_S_0067", "split": "test"}
{"name": "CompHaus_has_precisely_two_coreflective_subcategories", "problem_id": "S_0033_CompHaus_has_precisely_two_coreflective_subcategories", "informal_prefix": "", "formal_statement": "theorem CompHaus_has_precisely_two_coreflective_subcategories :\n    Nat.card (FullCoreflectiveSubcategory CompHaus) = 2 := by\n  sorry\n\nend CAT_statement_S_0033", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ntheorem CompHaus_has_precisely_two_coreflective_subcategories :\n    Nat.card (FullCoreflectiveSubcategory CompHaus) = 2 := by\n  sorry\n\nend CAT_statement_S_0033", "split": "test"}
{"name": "monic_of_comp_monic", "problem_id": "S_0002_monic_of_comp_monic", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type*} [Category C]\n\n\ntheorem monic_of_comp_monic {X Y Z : C} (g : X ‚ü∂ Y) (f : Y ‚ü∂ Z)\n    [Mono (g ‚â´ f)] : Mono g := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type*} [Category C]\n\n\ntheorem monic_of_comp_monic {X Y Z : C} (g : X ‚ü∂ Y) (f : Y ‚ü∂ Z)\n    [Mono (g ‚â´ f)] : Mono g := by\n  sorry", "split": "test"}
{"name": "unique_simple_object", "problem_id": "S_0082_unique_simple_object", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen Module\n\nvariable (ùïú : Type u) [Field ùïú]\n\ninstance isSimpleModule_self : IsSimpleModule ùïú ùïú := by\n  constructor\n  intro N\n  have : IsSimpleOrder (Submodule ùïú ùïú) := by infer_instance\n  exact eq_bot_or_eq_top N\n\ntheorem unique_simple_object (M : Type v) [AddCommGroup M] [Module ùïú M] [IsSimpleModule ùïú M] :\n    Nonempty (M ‚âÉ‚Çó[ùïú] ùïú) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen Module\n\nvariable (ùïú : Type u) [Field ùïú]\n\ninstance isSimpleModule_self : IsSimpleModule ùïú ùïú := by\n  constructor\n  intro N\n  have : IsSimpleOrder (Submodule ùïú ùïú) := by infer_instance\n  exact eq_bot_or_eq_top N\n\ntheorem unique_simple_object (M : Type v) [AddCommGroup M] [Module ùïú M] [IsSimpleModule ùïú M] :\n    Nonempty (M ‚âÉ‚Çó[ùïú] ùïú) := by\n  sorry", "split": "test"}
{"name": "isIso_iff_mono_and_epi", "problem_id": "S_0080_isIso_iff_mono_and_epi", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type*} [Category C] [Abelian C]\n\ntheorem isIso_iff_mono_and_epi {X Y : C} (f : X ‚ü∂ Y) :\n    IsIso f ‚Üî (Mono f ‚àß Epi f) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type*} [Category C] [Abelian C]\n\ntheorem isIso_iff_mono_and_epi {X Y : C} (f : X ‚ü∂ Y) :\n    IsIso f ‚Üî (Mono f ‚àß Epi f) := by\n  sorry", "split": "test"}
{"name": "monadOfRightAdjoint", "problem_id": "S_0094_monadOfRightAdjoint", "informal_prefix": "", "formal_statement": "def monadOfRightAdjoint (U : Functor C B) [IsRightAdjoint U] : Monad B :=\n  (Adjunction.ofIsRightAdjoint U).toMonad", "lean4_code": "import Mathlib\nopen CategoryTheory Functor\n\ndef monadOfRightAdjoint (U : Functor C B) [IsRightAdjoint U] : Monad B :=\n  (Adjunction.ofIsRightAdjoint U).toMonad", "split": "test"}
{"name": "IsIsoClosed", "problem_id": "S_0094_IsIsoClosed", "informal_prefix": "", "formal_statement": "def IsIsoClosed (U : Functor C B) := ‚àÄ (x : C) (y : B) (f : U.obj x ‚ü∂ y) [IsIso f], ‚àÉ (z : C), y = U.obj z\n\nvariable {U : Functor C B} [Full U] [Faithful U] [IsRightAdjoint U]\n  {h_inj : Function.Injective U.obj}\n  {h_iso_closed : IsIsoClosed U}", "lean4_code": "import Mathlib\nopen CategoryTheory Functor\n\ndef IsIsoClosed (U : Functor C B) := ‚àÄ (x : C) (y : B) (f : U.obj x ‚ü∂ y) [IsIso f], ‚àÉ (z : C), y = U.obj z\n\nvariable {U : Functor C B} [Full U] [Faithful U] [IsRightAdjoint U]\n  {h_inj : Function.Injective U.obj}\n  {h_iso_closed : IsIsoClosed U}", "split": "test"}
{"name": "monad_idempotent_of_full_reflective_embedding", "problem_id": "S_0094_monad_idempotent_of_full_reflective_embedding", "informal_prefix": "", "formal_statement": "theorem monad_idempotent_of_full_reflective_embedding :\n    let T : Monad B := monadOfRightAdjoint U\n    IsIso T.Œº := by\n  sorry\n\nend CAT_statement_S_0094", "lean4_code": "import Mathlib\nopen CategoryTheory Functor\n\ntheorem monad_idempotent_of_full_reflective_embedding :\n    let T : Monad B := monadOfRightAdjoint U\n    IsIso T.Œº := by\n  sorry\n\nend CAT_statement_S_0094", "split": "test"}
{"name": "complete_lattice_category", "problem_id": "S_0041_complete_lattice_category", "informal_prefix": "", "formal_statement": "theorem complete_lattice_category (X : Type u) :\n    Nonempty (FreeObject (C := CompleteLat) X) ‚Üî Cardinal.mk X ‚â§ 2 := by\n    sorry\n\nend CAT_statement_S_0041", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem complete_lattice_category (X : Type u) :\n    Nonempty (FreeObject (C := CompleteLat) X) ‚Üî Cardinal.mk X ‚â§ 2 := by\n    sorry\n\nend CAT_statement_S_0041", "split": "test"}
{"name": "t_algebra_equiv_modulecat", "problem_id": "S_0096_t_algebra_equiv_modulecat", "informal_prefix": "", "formal_statement": "theorem t_algebra_equiv_modulecat :\n    Nonempty (Monad.Algebra (T (R := R)) ‚âå ModuleCat.{max u v} R) := by\n  sorry\n\nend CAT_statement_S_0096", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem t_algebra_equiv_modulecat :\n    Nonempty (Monad.Algebra (T (R := R)) ‚âå ModuleCat.{max u v} R) := by\n  sorry\n\nend CAT_statement_S_0096", "split": "test"}
{"name": "mono_iff_exists_embedding_section", "problem_id": "S_0012_mono_iff_exists_embedding_section", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Functor\n\n\ntheorem mono_iff_exists_embedding_section\n  {C : Type u} [Category.{v} C] {X Y : C} (f : X ‚ü∂ Y) :\n    Mono f ‚Üî ‚àÉ (D : Type (max u v)) (_ : Category.{v} D) (I : C ‚•§ D) (_ : Faithful I),\n    IsSplitMono (I.map f) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Functor\n\n\ntheorem mono_iff_exists_embedding_section\n  {C : Type u} [Category.{v} C] {X Y : C} (f : X ‚ü∂ Y) :\n    Mono f ‚Üî ‚àÉ (D : Type (max u v)) (_ : Category.{v} D) (I : C ‚•§ D) (_ : Faithful I),\n    IsSplitMono (I.map f) := by\n  sorry", "split": "test"}
{"name": "mono_iff_isZero_kernel", "problem_id": "S_0081_mono_iff_isZero_kernel", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits Category\n\nvariable {C : Type*} [Category C] [Abelian C]\n\ntheorem mono_iff_isZero_kernel {X Y : C} (f : X ‚ü∂ Y) :\n    Mono f ‚Üî IsZero (kernel f) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits Category\n\nvariable {C : Type*} [Category C] [Abelian C]\n\ntheorem mono_iff_isZero_kernel {X Y : C} (f : X ‚ü∂ Y) :\n    Mono f ‚Üî IsZero (kernel f) := by\n  sorry", "split": "test"}
{"name": "Function", "problem_id": "S_0052_Function", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits Functor Types Function Pullback\n\ntheorem Function.isPullback_pulllback {X Y Z : Type u} (f : X ‚Üí Z) (g : Y ‚Üí Z) :\n    IsPullback (C := Type u) (fst (f := f) (g := g)) snd f g := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits Functor Types Function Pullback\n\ntheorem Function.isPullback_pulllback {X Y Z : Type u} (f : X ‚Üí Z) (g : Y ‚Üí Z) :\n    IsPullback (C := Type u) (fst (f := f) (g := g)) snd f g := by\n  sorry", "split": "test"}
{"name": "id_comm", "problem_id": "S_0001_id_comm", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type*} [Category.{v} C]\n\ntheorem id_comm (Œ± Œ≤ : (ùü≠ C) ‚ü∂ (ùü≠ C)) : Œ± ‚â´ Œ≤ = Œ≤ ‚â´ Œ± := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type*} [Category.{v} C]\n\ntheorem id_comm (Œ± Œ≤ : (ùü≠ C) ‚ü∂ (ùü≠ C)) : Œ± ‚â´ Œ≤ = Œ≤ ‚â´ Œ± := by\n  sorry", "split": "test"}
{"name": "IsIsoClosed", "problem_id": "S_0032_IsIsoClosed", "informal_prefix": "", "formal_statement": "def IsIsoClosed (P : Type u ‚Üí Prop) : Prop :=\n  ‚àÄ {X Y : Type u}, Nonempty (X ‚âÖ Y) ‚Üí P X ‚Üí P Y", "lean4_code": "import Mathlib\nopen CategoryTheory Functor Limits\n\ndef IsIsoClosed (P : Type u ‚Üí Prop) : Prop :=\n  ‚àÄ {X Y : Type u}, Nonempty (X ‚âÖ Y) ‚Üí P X ‚Üí P Y", "split": "test"}
{"name": "SubcategoryEquiv", "problem_id": "S_0032_SubcategoryEquiv", "informal_prefix": "", "formal_statement": "def SubcategoryEquiv (P Q : Type u ‚Üí Prop) : Prop :=\n  ‚àÄ X, P X ‚Üî Q X", "lean4_code": "import Mathlib\nopen CategoryTheory Functor Limits\n\ndef SubcategoryEquiv (P Q : Type u ‚Üí Prop) : Prop :=\n  ‚àÄ X, P X ‚Üî Q X", "split": "test"}
{"name": "IsReflectiveSubcategory", "problem_id": "S_0032_IsReflectiveSubcategory", "informal_prefix": "", "formal_statement": "def IsReflectiveSubcategory (P : Type u ‚Üí Prop) : Prop :=\n  Nonempty (Reflective (ObjectProperty.Œπ P))", "lean4_code": "import Mathlib\nopen CategoryTheory Functor Limits\n\ndef IsReflectiveSubcategory (P : Type u ‚Üí Prop) : Prop :=\n  Nonempty (Reflective (ObjectProperty.Œπ P))", "split": "test"}
{"name": "Set_has_precisely_three_reflective_subcategories", "problem_id": "S_0032_Set_has_precisely_three_reflective_subcategories", "informal_prefix": "", "formal_statement": "theorem Set_has_precisely_three_reflective_subcategories :\n    ‚àÉ (P‚ÇÅ P‚ÇÇ P‚ÇÉ : Type u ‚Üí Prop),\n      IsIsoClosed P‚ÇÅ ‚àß IsReflectiveSubcategory P‚ÇÅ ‚àß\n      IsIsoClosed P‚ÇÇ ‚àß IsReflectiveSubcategory P‚ÇÇ ‚àß\n      IsIsoClosed P‚ÇÉ ‚àß IsReflectiveSubcategory P‚ÇÉ ‚àß\n      ¬¨ SubcategoryEquiv P‚ÇÅ P‚ÇÇ ‚àß ¬¨ SubcategoryEquiv P‚ÇÇ P‚ÇÉ ‚àß ¬¨ SubcategoryEquiv P‚ÇÅ P‚ÇÉ ‚àß\n      ‚àÄ (Q : Type u ‚Üí Prop), IsIsoClosed Q ‚Üí IsReflectiveSubcategory Q ‚Üí\n        (SubcategoryEquiv Q P‚ÇÅ ‚à® SubcategoryEquiv Q P‚ÇÇ ‚à® SubcategoryEquiv Q P‚ÇÉ) := by\n  sorry\n\nend CAT_statement_S_0032", "lean4_code": "import Mathlib\nopen CategoryTheory Functor Limits\n\ntheorem Set_has_precisely_three_reflective_subcategories :\n    ‚àÉ (P‚ÇÅ P‚ÇÇ P‚ÇÉ : Type u ‚Üí Prop),\n      IsIsoClosed P‚ÇÅ ‚àß IsReflectiveSubcategory P‚ÇÅ ‚àß\n      IsIsoClosed P‚ÇÇ ‚àß IsReflectiveSubcategory P‚ÇÇ ‚àß\n      IsIsoClosed P‚ÇÉ ‚àß IsReflectiveSubcategory P‚ÇÉ ‚àß\n      ¬¨ SubcategoryEquiv P‚ÇÅ P‚ÇÇ ‚àß ¬¨ SubcategoryEquiv P‚ÇÇ P‚ÇÉ ‚àß ¬¨ SubcategoryEquiv P‚ÇÅ P‚ÇÉ ‚àß\n      ‚àÄ (Q : Type u ‚Üí Prop), IsIsoClosed Q ‚Üí IsReflectiveSubcategory Q ‚Üí\n        (SubcategoryEquiv Q P‚ÇÅ ‚à® SubcategoryEquiv Q P‚ÇÇ ‚à® SubcategoryEquiv Q P‚ÇÉ) := by\n  sorry\n\nend CAT_statement_S_0032", "split": "test"}
{"name": "hasInitial_iff_exists_weakly_initial", "problem_id": "S_0054_hasInitial_iff_exists_weakly_initial", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {B : Type u} [Category.{v} B]\n\ntheorem hasInitial_iff_exists_weakly_initial [HasLimits B] :\n    HasInitial B ‚Üî ‚àÉ (I : Type v) (x : I ‚Üí B), ‚àÄ (s : B), ‚àÉ (i : I), Nonempty (x i ‚ü∂ s) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {B : Type u} [Category.{v} B]\n\ntheorem hasInitial_iff_exists_weakly_initial [HasLimits B] :\n    HasInitial B ‚Üî ‚àÉ (I : Type v) (x : I ‚Üí B), ‚àÄ (s : B), ‚àÉ (i : I), Nonempty (x i ‚ü∂ s) := by\n  sorry", "split": "test"}
{"name": "comparison_adjunction", "problem_id": "S_0097_comparison_adjunction", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Monad\n\nuniverse u‚ÇÅ u‚ÇÇ v‚ÇÅ\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÅ} D]\nvariable (F : C ‚•§ D) (G : D ‚•§ C) (adj : F ‚ä£ G)\n\ntheorem comparison_adjunction\n    [‚àÄ (A : adj.toMonad.Algebra), Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    ‚àÉ K : adj.toMonad.Algebra ‚•§ D, Nonempty (K ‚ä£ comparison adj) := by\n    sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Monad\n\nuniverse u‚ÇÅ u‚ÇÇ v‚ÇÅ\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÅ} D]\nvariable (F : C ‚•§ D) (G : D ‚•§ C) (adj : F ‚ä£ G)\n\ntheorem comparison_adjunction\n    [‚àÄ (A : adj.toMonad.Algebra), Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    ‚àÉ K : adj.toMonad.Algebra ‚•§ D, Nonempty (K ‚ä£ comparison adj) := by\n    sorry", "split": "test"}
{"name": "int_endofunctor_hasLeftAdjoint_iff_hasRightAdjoint", "problem_id": "S_0027_int_endofunctor_hasLeftAdjoint_iff_hasRightAdjoint", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\ntheorem int_endofunctor_hasLeftAdjoint_iff_hasRightAdjoint (f : ‚Ñ§ ‚•§ ‚Ñ§) :\n    f.IsRightAdjoint ‚Üî f.IsLeftAdjoint := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\ntheorem int_endofunctor_hasLeftAdjoint_iff_hasRightAdjoint (f : ‚Ñ§ ‚•§ ‚Ñ§) :\n    f.IsRightAdjoint ‚Üî f.IsLeftAdjoint := by\n  sorry", "split": "test"}
{"name": "idempotent_splitting_from_epi_mono_factorization", "problem_id": "S_0005_idempotent_splitting_from_epi_mono_factorization", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Idempotents\n\nvariable {C : Type*} [Category.{v} C]\n\ntheorem idempotent_splitting_from_epi_mono_factorization \n    (h : ‚àÄ (X : C) (p : X ‚ü∂ X) (hpp : p ‚â´ p = p), \n      ‚àÉ (Y : C) (e : X ‚ü∂ Y) (he : Epi e) (m : Y ‚ü∂ X) (hm : Mono m), p = e ‚â´ m) : \n    IsIdempotentComplete C := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Idempotents\n\nvariable {C : Type*} [Category.{v} C]\n\ntheorem idempotent_splitting_from_epi_mono_factorization \n    (h : ‚àÄ (X : C) (p : X ‚ü∂ X) (hpp : p ‚â´ p = p), \n      ‚àÉ (Y : C) (e : X ‚ü∂ Y) (he : Epi e) (m : Y ‚ü∂ X) (hm : Mono m), p = e ‚â´ m) : \n    IsIdempotentComplete C := by\n  sorry", "split": "test"}
{"name": "exists_category_not_concretizable_over_Type", "problem_id": "S_0036_exists_category_not_concretizable_over_Type", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\ntheorem exists_category_not_concretizable_over_Type :\n    ‚àÉ (C : Type u) (_ : Category.{v} C), ¬¨ ‚àÉ (F : C ‚•§ Type v), F.Faithful := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\ntheorem exists_category_not_concretizable_over_Type :\n    ‚àÉ (C : Type u) (_ : Category.{v} C), ¬¨ ‚àÉ (F : C ‚•§ Type v), F.Faithful := by\n  sorry", "split": "test"}
{"name": "fully_faithful_reflects_limits_and_colimits", "problem_id": "S_0042_fully_faithful_reflects_limits_and_colimits", "informal_prefix": "", "formal_statement": "theorem fully_faithful_reflects_limits_and_colimits (F : C ‚•§ D) [Full F] [Faithful F] :\n    ReflectsLimits F ‚àß ReflectsColimits F := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Functor\n\ntheorem fully_faithful_reflects_limits_and_colimits (F : C ‚•§ D) [Full F] [Faithful F] :\n    ReflectsLimits F ‚àß ReflectsColimits F := by\n  sorry", "split": "test"}
{"name": "AddCommGrpConcrete", "problem_id": "S_0016_AddCommGrpConcrete", "informal_prefix": "", "formal_statement": "def AddCommGrpConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := AddCommGrp.{u}\n  U := forget AddCommGrp}", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef AddCommGrpConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := AddCommGrp.{u}\n  U := forget AddCommGrp}", "split": "test"}
{"name": "ZMod_simple", "problem_id": "S_0083_ZMod_simple", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable (p : ‚Ñï) [Fact p.Prime]\n\ntheorem ZMod_simple : CategoryTheory.Simple (ModuleCat.of ‚Ñ§ (ZMod p)) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable (p : ‚Ñï) [Fact p.Prime]\n\ntheorem ZMod_simple : CategoryTheory.Simple (ModuleCat.of ‚Ñ§ (ZMod p)) := by\n  sorry", "split": "test"}
{"name": "compIsBilinear", "problem_id": "S_0079_compIsBilinear", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type u} [Category.{v} C] [Preadditive C]\n\nstructure IsBilinear {X Y Z : C} (f : (Y ‚ü∂ Z) ‚Üí ((X ‚ü∂ Y) ‚Üí (X ‚ü∂ Z))) : Prop where\n  map_add_left : ‚àÄ (a b : Y ‚ü∂ Z) (g : X ‚ü∂ Y),\n    f (a + b) g = f a g + f b g\n\n  map_add_right : ‚àÄ (a : Y ‚ü∂ Z) (g h : X ‚ü∂ Y), f a (g + h) = f a g + f a h\n\n  map_zero_left : ‚àÄ (g : X ‚ü∂ Y), f 0 g = 0\n\n  map_zero_right : ‚àÄ (a : Y ‚ü∂ Z), f a 0 = 0\n\n\ntheorem compIsBilinear {X Y Z : C} :\n    IsBilinear (fun (g : Y ‚ü∂ Z) => (fun (f : (X ‚ü∂ Y)) => f ‚â´ g)) := sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type u} [Category.{v} C] [Preadditive C]\n\nstructure IsBilinear {X Y Z : C} (f : (Y ‚ü∂ Z) ‚Üí ((X ‚ü∂ Y) ‚Üí (X ‚ü∂ Z))) : Prop where\n  map_add_left : ‚àÄ (a b : Y ‚ü∂ Z) (g : X ‚ü∂ Y),\n    f (a + b) g = f a g + f b g\n\n  map_add_right : ‚àÄ (a : Y ‚ü∂ Z) (g h : X ‚ü∂ Y), f a (g + h) = f a g + f a h\n\n  map_zero_left : ‚àÄ (g : X ‚ü∂ Y), f 0 g = 0\n\n  map_zero_right : ‚àÄ (a : Y ‚ü∂ Z), f a 0 = 0\n\n\ntheorem compIsBilinear {X Y Z : C} :\n    IsBilinear (fun (g : Y ‚ü∂ Z) => (fun (f : (X ‚ü∂ Y)) => f ‚â´ g)) := sorry", "split": "test"}
{"name": "functor_faithful_iff_reflectsEpimorphisms_of_liftsEqualizers", "problem_id": "S_0071_functor_faithful_iff_reflectsEpimorphisms_of_liftsEqualizers", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nnamespace CAT_statement_S_0071\n\nuniverse uC vC uD vD w w'\n\nvariable {C : Type uC} [Category.{vC} C]\nvariable {D : Type uD} [Category.{vD} D]\nvariable (F : C ‚•§ D)\nvariable {J : Type w} [Category.{w'} J]\n\nclass LiftsLimit  (K : J ‚•§ C) (F : C ‚•§ D): Prop where\n    lifts {c : Cone (K ‚ãô F)} (hc : IsLimit c) :\n      ‚àÉ c' : Cone K, Nonempty (IsLimit c') ‚àß Nonempty (F.mapCone c' ‚âÖ c)\n\nclass LiftsLimitsOfShape (J : Type w) [Category.{w'} J] (F : C ‚•§ D) : Prop where\n  liftsLimit : ‚àÄ {K : J ‚•§ C}, LiftsLimit K F := by infer_instance\n\ntheorem functor_faithful_iff_reflectsEpimorphisms_of_liftsEqualizers\n    [LiftsLimitsOfShape Limits.WalkingParallelPair F] :\n    F.Faithful ‚Üî F.ReflectsEpimorphisms := by\n  sorry\n\nend CAT_statement_S_0071", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nnamespace CAT_statement_S_0071\n\nuniverse uC vC uD vD w w'\n\nvariable {C : Type uC} [Category.{vC} C]\nvariable {D : Type uD} [Category.{vD} D]\nvariable (F : C ‚•§ D)\nvariable {J : Type w} [Category.{w'} J]\n\nclass LiftsLimit  (K : J ‚•§ C) (F : C ‚•§ D): Prop where\n    lifts {c : Cone (K ‚ãô F)} (hc : IsLimit c) :\n      ‚àÉ c' : Cone K, Nonempty (IsLimit c') ‚àß Nonempty (F.mapCone c' ‚âÖ c)\n\nclass LiftsLimitsOfShape (J : Type w) [Category.{w'} J] (F : C ‚•§ D) : Prop where\n  liftsLimit : ‚àÄ {K : J ‚•§ C}, LiftsLimit K F := by infer_instance\n\ntheorem functor_faithful_iff_reflectsEpimorphisms_of_liftsEqualizers\n    [LiftsLimitsOfShape Limits.WalkingParallelPair F] :\n    F.Faithful ‚Üî F.ReflectsEpimorphisms := by\n  sorry\n\nend CAT_statement_S_0071", "split": "test"}
{"name": "IsAdditiveCategory", "problem_id": "S_0084_IsAdditiveCategory", "informal_prefix": "", "formal_statement": "def IsAdditiveCategory (C : Type u) [Category.{v} C] : Prop :=\n  ‚àÉ (_ : Preadditive C), HasZeroObject C ‚àß HasFiniteBiproducts C", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef IsAdditiveCategory (C : Type u) [Category.{v} C] : Prop :=\n  ‚àÉ (_ : Preadditive C), HasZeroObject C ‚àß HasFiniteBiproducts C", "split": "test"}
{"name": "Grp_not_is_additive", "problem_id": "S_0084_Grp_not_is_additive", "informal_prefix": "", "formal_statement": "theorem Grp_not_is_additive : IsEmpty (IsAdditiveCategory Grp.{u}) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem Grp_not_is_additive : IsEmpty (IsAdditiveCategory Grp.{u}) := by\n  sorry", "split": "test"}
{"name": "fully_faithful_iff_unit_isIso", "problem_id": "S_0020_fully_faithful_iff_unit_isIso", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (F : C ‚•§ D) (G : D ‚•§ C)\n\ntheorem fully_faithful_iff_unit_isIso (adj : F ‚ä£ G) :\n    (F.Full ‚àß F.Faithful) ‚Üî IsIso adj.unit := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (F : C ‚•§ D) (G : D ‚•§ C)\n\ntheorem fully_faithful_iff_unit_isIso (adj : F ‚ä£ G) :\n    (F.Full ‚àß F.Faithful) ‚Üî IsIso adj.unit := by\n  sorry", "split": "test"}
{"name": "isRecObject_yoneda", "problem_id": "S_0075_isRecObject_yoneda", "informal_prefix": "", "formal_statement": "theorem isRecObject_yoneda (X : C) :\n    IsRecObject (C := C) ((yoneda : C ‚•§ Psh C).obj X) :=\n  ‚ü®‚ü®RecObjectPresentation.ofYoneda (C := C) X‚ü©‚ü©", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\nopen Limits Functor\nopen Limits\n\ntheorem isRecObject_yoneda (X : C) :\n    IsRecObject (C := C) ((yoneda : C ‚•§ Psh C).obj X) :=\n  ‚ü®‚ü®RecObjectPresentation.ofYoneda (C := C) X‚ü©‚ü©", "split": "test"}
{"name": "Rec", "problem_id": "S_0075_Rec", "informal_prefix": "", "formal_statement": "def Rec : Type (max u (v + 1)) :=\n  ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C)))\n\nnoncomputable instance : Category.{max u v} (Rec C) :=\n  inferInstanceAs <| Category.{max u v}\n    (ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C))))\n\n\nnoncomputable def Rec.equivalence :\n    Rec C ‚âå ObjectProperty.FullSubcategory (IsRecObject (C := C)) :=\n  (ShrinkHoms.equivalence _).symm", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\nopen Limits Functor\nopen Limits\n\ndef Rec : Type (max u (v + 1)) :=\n  ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C)))\n\nnoncomputable instance : Category.{max u v} (Rec C) :=\n  inferInstanceAs <| Category.{max u v}\n    (ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C))))\n\n\nnoncomputable def Rec.equivalence :\n    Rec C ‚âå ObjectProperty.FullSubcategory (IsRecObject (C := C)) :=\n  (ShrinkHoms.equivalence _).symm", "split": "test"}
{"name": "pro_fintypecat_equiv_profinite", "problem_id": "S_0076_pro_fintypecat_equiv_profinite", "informal_prefix": "", "formal_statement": "theorem pro_fintypecat_equiv_profinite : Nonempty ((Pro (FintypeCat)) ‚âå Profinite) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem pro_fintypecat_equiv_profinite : Nonempty ((Pro (FintypeCat)) ‚âå Profinite) := by\n  sorry", "split": "test"}
{"name": "colimit_is_leftKanExtension_along_to_terminal", "problem_id": "S_0049_colimit_is_leftKanExtension_along_to_terminal", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nuniverse u‚ÇÅ v‚ÇÅ u‚ÇÇ v‚ÇÇ\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]\nvariable {E : Type u‚ÇÇ} [Category.{v‚ÇÇ} E]\n\n\ntheorem colimit_is_leftKanExtension_along_to_terminal\n    (F : C ‚•§ E) (K : C ‚•§ PUnit) [HasColimit F] [K.HasLeftKanExtension F] :\n    Nonempty ((K.leftKanExtension F).obj PUnit.unit ‚âÖ colimit F) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nuniverse u‚ÇÅ v‚ÇÅ u‚ÇÇ v‚ÇÇ\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]\nvariable {E : Type u‚ÇÇ} [Category.{v‚ÇÇ} E]\n\n\ntheorem colimit_is_leftKanExtension_along_to_terminal\n    (F : C ‚•§ E) (K : C ‚•§ PUnit) [HasColimit F] [K.HasLeftKanExtension F] :\n    Nonempty ((K.leftKanExtension F).obj PUnit.unit ‚âÖ colimit F) := by\n  sorry", "split": "test"}
{"name": "isLeftAdjoint_iff_yoneda_comp_op_isRepresentable", "problem_id": "S_0022_isLeftAdjoint_iff_yoneda_comp_op_isRepresentable", "informal_prefix": "", "formal_statement": "theorem isLeftAdjoint_iff_yoneda_comp_op_isRepresentable (F : C ‚•§ D) :\n    F.IsLeftAdjoint ‚Üî ‚àÄ (d : D), (F.op ‚ãô yoneda.obj d).IsRepresentable := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem isLeftAdjoint_iff_yoneda_comp_op_isRepresentable (F : C ‚•§ D) :\n    F.IsLeftAdjoint ‚Üî ‚àÄ (d : D), (F.op ‚ãô yoneda.obj d).IsRepresentable := by\n  sorry", "split": "test"}
{"name": "forget", "problem_id": "S_0015_forget", "informal_prefix": "", "formal_statement": "def forget : SemilatInfCat.{u} ‚•§ Type u where\n  obj A := A\n  map {A B} f := f\n\n\ninstance : forget.Faithful  where\n  map_injective {A B} f g h := by\n    ext x\n    simpa using congrArg (fun k => k x) h", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef forget : SemilatInfCat.{u} ‚•§ Type u where\n  obj A := A\n  map {A B} f := f\n\n\ninstance : forget.Faithful  where\n  map_injective {A B} f g h := by\n    ext x\n    simpa using congrArg (fun k => k x) h", "split": "test"}
{"name": "SemilatInfCatConcrete", "problem_id": "S_0015_SemilatInfCatConcrete", "informal_prefix": "", "formal_statement": "def SemilatInfCatConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := SemilatInfCat.{u}\n  U := forget }\n\n\nclass IsFrameObj (P : SemilatInfCat.{u}) (sSup : Set P.X ‚Üí P.X) (sInf : Set P.X ‚Üí P.X): Prop where\n  exists_sSup :\n      (‚àÄ (s : Set P.X), IsLUB s (sSup s))\n  exists_sInf :\n      (‚àÄ (s : Set P.X), IsGLB s (sInf s))\n  distributive :\n      (‚àÄ (a : P.X), ‚àÄ (s : Set P.X),\n        a ‚äì sSup s = sSup (Set.image (fun (b : P.X) => a ‚äì b) s))", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef SemilatInfCatConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := SemilatInfCat.{u}\n  U := forget }\n\n\nclass IsFrameObj (P : SemilatInfCat.{u}) (sSup : Set P.X ‚Üí P.X) (sInf : Set P.X ‚Üí P.X): Prop where\n  exists_sSup :\n      (‚àÄ (s : Set P.X), IsLUB s (sSup s))\n  exists_sInf :\n      (‚àÄ (s : Set P.X), IsGLB s (sInf s))\n  distributive :\n      (‚àÄ (a : P.X), ‚àÄ (s : Set P.X),\n        a ‚äì sSup s = sSup (Set.image (fun (b : P.X) => a ‚äì b) s))", "split": "test"}
{"name": "AHS_injective_iff_frameObj", "problem_id": "S_0015_AHS_injective_iff_frameObj", "informal_prefix": "", "formal_statement": "theorem AHS_injective_iff_frameObj (P : SemilatInfCat) :\n    AHS.IsInjectiveObj (C := SemilatInfCatConcrete) P ‚Üî ‚àÉ (sSup : Set P.X ‚Üí P.X) (sInf : Set P.X ‚Üí P.X), IsFrameObj P sSup sInf := by\n  sorry\n\nend SemilatInfCat\n\nend CAT_statement_S_0015", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem AHS_injective_iff_frameObj (P : SemilatInfCat) :\n    AHS.IsInjectiveObj (C := SemilatInfCatConcrete) P ‚Üî ‚àÉ (sSup : Set P.X ‚Üí P.X) (sInf : Set P.X ‚Üí P.X), IsFrameObj P sSup sInf := by\n  sorry\n\nend SemilatInfCat\n\nend CAT_statement_S_0015", "split": "test"}
{"name": "forget_CommGrp_to_Grp_admits_left_adjoint", "problem_id": "S_0024_forget_CommGrp_to_Grp_admits_left_adjoint", "informal_prefix": "", "formal_statement": "import Mathlib\nopen CategoryTheory\nuniverse u\n\ntheorem forget_CommGrp_to_Grp_admits_left_adjoint :\n    (forget‚ÇÇ CommGrp.{u} Grp.{u}).IsRightAdjoint := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\nuniverse u\n\ntheorem forget_CommGrp_to_Grp_admits_left_adjoint :\n    (forget‚ÇÇ CommGrp.{u} Grp.{u}).IsRightAdjoint := by\n  sorry", "split": "test"}
{"name": "monad_forget_has_left_adjoint", "problem_id": "S_0091_monad_forget_has_left_adjoint", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]\n\n\ntheorem monad_forget_has_left_adjoint (T : Monad C) :\n    T.forget.IsRightAdjoint := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]\n\n\ntheorem monad_forget_has_left_adjoint (T : Monad C) :\n    T.forget.IsRightAdjoint := by\n  sorry", "split": "test"}
{"name": "exists_functor_lifts_limit_and_not_faithful", "problem_id": "S_0059_exists_functor_lifts_limit_and_not_faithful", "informal_prefix": "", "formal_statement": "theorem exists_functor_lifts_limit_and_not_faithful :\n    ‚àÉ (C : Type (u‚ÇÅ+1)) (_ : Category.{u‚ÇÅ} C) (D : Type u‚ÇÇ) (_ : Category.{u‚ÇÇ} D) (F : C ‚•§ D), (‚àÄ (J : Type u‚ÇÅ) (_ : Category.{w'} J) (K : J ‚•§ C), Nonempty (LiftsLimit K F)) ‚àß\n    ¬¨ F.Faithful := by\n  sorry\n\nend CAT_statement_S_0059", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem exists_functor_lifts_limit_and_not_faithful :\n    ‚àÉ (C : Type (u‚ÇÅ+1)) (_ : Category.{u‚ÇÅ} C) (D : Type u‚ÇÇ) (_ : Category.{u‚ÇÇ} D) (F : C ‚•§ D), (‚àÄ (J : Type u‚ÇÅ) (_ : Category.{w'} J) (K : J ‚•§ C), Nonempty (LiftsLimit K F)) ‚àß\n    ¬¨ F.Faithful := by\n  sorry\n\nend CAT_statement_S_0059", "split": "test"}
{"name": "IsFinitelyPresentedGrp", "problem_id": "S_0063_IsFinitelyPresentedGrp", "informal_prefix": "", "formal_statement": "def IsFinitelyPresentedGrp (X : Type u) [Group X] : Prop :=\n    ‚àÉ (Œ± : Type u) (rels : Set (FreeGroup Œ±)), Finite Œ± ‚àß rels.Finite ‚àß Nonempty (X ‚âÉ* PresentedGroup rels)", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef IsFinitelyPresentedGrp (X : Type u) [Group X] : Prop :=\n    ‚àÉ (Œ± : Type u) (rels : Set (FreeGroup Œ±)), Finite Œ± ‚àß rels.Finite ‚àß Nonempty (X ‚âÉ* PresentedGroup rels)", "split": "test"}
{"name": "isCompactObject_Grp_iff_finite_presented", "problem_id": "S_0063_isCompactObject_Grp_iff_finite_presented", "informal_prefix": "", "formal_statement": "theorem isCompactObject_Grp_iff_finite_presented (X : Type u) [Group X] :\n    CategoryTheory.IsFinitelyPresentable (Grp.of X) ‚Üî IsFinitelyPresentedGrp X := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem isCompactObject_Grp_iff_finite_presented (X : Type u) [Group X] :\n    CategoryTheory.IsFinitelyPresentable (Grp.of X) ‚Üî IsFinitelyPresentedGrp X := by\n  sorry", "split": "test"}
{"name": "group_realized_as_direct_limit_of_finitely_presented_groups", "problem_id": "S_0063_group_realized_as_direct_limit_of_finitely_presented_groups", "informal_prefix": "", "formal_statement": "theorem group_realized_as_direct_limit_of_finitely_presented_groups (X : Type u) [Group X] :\n    ‚àÉ (J : Type u) (inst‚ÇÅ : CategoryTheory.SmallCategory J) (inst‚ÇÇ : CategoryTheory.IsFiltered J) (F : CategoryTheory.Functor J Grp), ‚àÄ (j : J), IsFinitelyPresentedGrp (F.obj j) ‚àß Nonempty (X ‚âÉ* Grp.FilteredColimits.colimit F) := by\n    sorry\n\nend CAT_statement_S_0063", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem group_realized_as_direct_limit_of_finitely_presented_groups (X : Type u) [Group X] :\n    ‚àÉ (J : Type u) (inst‚ÇÅ : CategoryTheory.SmallCategory J) (inst‚ÇÇ : CategoryTheory.IsFiltered J) (F : CategoryTheory.Functor J Grp), ‚àÄ (j : J), IsFinitelyPresentedGrp (F.obj j) ‚àß Nonempty (X ‚âÉ* Grp.FilteredColimits.colimit F) := by\n    sorry\n\nend CAT_statement_S_0063", "split": "test"}
{"name": "module_realized_as_direct_limit_of_finitely_presented_modules", "problem_id": "S_0064_module_realized_as_direct_limit_of_finitely_presented_modules", "informal_prefix": "", "formal_statement": "theorem module_realized_as_direct_limit_of_finitely_presented_modules (A : Type u) [Ring A] (X : Type v) [AddCommGroup X] [Module A X] :\n    ‚àÉ (J : Type w) (inst‚ÇÅ : CategoryTheory.SmallCategory J) (inst‚ÇÇ : CategoryTheory.IsFiltered J) (F : CategoryTheory.Functor J (ModuleCat A)), ‚àÄ (j : J), Module.FinitePresentation A (F.obj j) ‚àß Nonempty (X ‚âÉ‚Çó[A] ModuleCat.FilteredColimits.colimit F) := by\n    sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem module_realized_as_direct_limit_of_finitely_presented_modules (A : Type u) [Ring A] (X : Type v) [AddCommGroup X] [Module A X] :\n    ‚àÉ (J : Type w) (inst‚ÇÅ : CategoryTheory.SmallCategory J) (inst‚ÇÇ : CategoryTheory.IsFiltered J) (F : CategoryTheory.Functor J (ModuleCat A)), ‚àÄ (j : J), Module.FinitePresentation A (F.obj j) ‚àß Nonempty (X ‚âÉ‚Çó[A] ModuleCat.FilteredColimits.colimit F) := by\n    sorry", "split": "test"}
{"name": "HasIntersections", "problem_id": "S_0066_HasIntersections", "informal_prefix": "", "formal_statement": "def HasIntersections (C : Type u) [Category.{v} C]: Prop :=\n  ‚àÄ (B : C) (S : Set (Subobject B)),\n    ‚àÉ A : Subobject B, IsIntersectionOf (C := C) (B := B) A S\n\nclass StronglyComplete (C : Type u) [Category.{v} C] : Prop where\n  complete: HasLimits C\n  hasinter: HasIntersections C\n\nclass StronglyCocomplete (C : Type u) [Category.{v} C] : Prop where\n  dual: StronglyComplete (C:=C·µí·µñ)", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef HasIntersections (C : Type u) [Category.{v} C]: Prop :=\n  ‚àÄ (B : C) (S : Set (Subobject B)),\n    ‚àÉ A : Subobject B, IsIntersectionOf (C := C) (B := B) A S\n\nclass StronglyComplete (C : Type u) [Category.{v} C] : Prop where\n  complete: HasLimits C\n  hasinter: HasIntersections C\n\nclass StronglyCocomplete (C : Type u) [Category.{v} C] : Prop where\n  dual: StronglyComplete (C:=C·µí·µñ)", "split": "test"}
{"name": "exists_cocomplete_separator_not_wellPowered_not_coWellPowered", "problem_id": "S_0066_exists_cocomplete_separator_not_wellPowered_not_coWellPowered", "informal_prefix": "", "formal_statement": "theorem exists_cocomplete_separator_not_wellPowered_not_coWellPowered :\n    ‚àÉ (C : Type u) (_ : Category.{v} C),\n    StronglyCocomplete C ‚àß HasSeparator C ‚àß\n    ¬¨ WellPowered.{v} C ‚àß ¬¨ WellPowered.{v} C·µí·µñ := by\n  sorry\n\nend CAT_statement_S_0066", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem exists_cocomplete_separator_not_wellPowered_not_coWellPowered :\n    ‚àÉ (C : Type u) (_ : Category.{v} C),\n    StronglyCocomplete C ‚àß HasSeparator C ‚àß\n    ¬¨ WellPowered.{v} C ‚àß ¬¨ WellPowered.{v} C·µí·µñ := by\n  sorry\n\nend CAT_statement_S_0066", "split": "test"}
{"name": "SetConcrete", "problem_id": "S_0037_SetConcrete", "informal_prefix": "", "formal_statement": "def SetConcrete : ConcreteCat (X := Type u) :=\n{ C := Type u\n  U := ùü≠ (Type u) }", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef SetConcrete : ConcreteCat (X := Type u) :=\n{ C := Type u\n  U := ùü≠ (Type u) }", "split": "test"}
{"name": "TopConcrete", "problem_id": "S_0037_TopConcrete", "informal_prefix": "", "formal_statement": "def TopConcrete : ConcreteCat (X := Type u) :=\n{ C := TopCat.{u}\n  U := (forget TopCat) }", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef TopConcrete : ConcreteCat (X := Type u) :=\n{ C := TopCat.{u}\n  U := (forget TopCat) }", "split": "test"}
{"name": "ConcreteFuncsIso", "problem_id": "S_0037_ConcreteFuncsIso", "informal_prefix": "", "formal_statement": "def ConcreteFuncsIso (A B : ConcreteCat (X := Type u)) : Type _ :=\n  { F : A.C ‚•§ B.C // IsConcreteFunc (A := A) (B := B) F }", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef ConcreteFuncsIso (A B : ConcreteCat (X := Type u)) : Type _ :=\n  { F : A.C ‚•§ B.C // IsConcreteFunc (A := A) (B := B) F }", "split": "test"}
{"name": "forgetFrm", "problem_id": "S_0039_forgetFrm", "informal_prefix": "", "formal_statement": "def forgetFrm : Frm.{u} ‚•§ Type u where\n  obj X := X\n  map {X Y} f := f\n\n\ninstance : forgetFrm.Faithful  where\n  map_injective {X Y} f g h := by\n    ext x\n    simpa using congrArg (fun k => k x) h\n\n\nstructure T0TopCat where\n  toTop : TopCat.{u}\n  is_t0 : T0Space (‚ÜëtoTop)\n\nnamespace T0TopCat\n\ninstance : CoeSort T0TopCat (Type u) := ‚ü®fun X => X.toTop‚ü©\ninstance (X : T0TopCat) : TopologicalSpace X := X.toTop.str\nattribute [instance] T0TopCat.is_t0\n\n\ninstance : Category T0TopCat :=\n  InducedCategory.category (fun X : T0TopCat => X.toTop)", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ndef forgetFrm : Frm.{u} ‚•§ Type u where\n  obj X := X\n  map {X Y} f := f\n\n\ninstance : forgetFrm.Faithful  where\n  map_injective {X Y} f g h := by\n    ext x\n    simpa using congrArg (fun k => k x) h\n\n\nstructure T0TopCat where\n  toTop : TopCat.{u}\n  is_t0 : T0Space (‚ÜëtoTop)\n\nnamespace T0TopCat\n\ninstance : CoeSort T0TopCat (Type u) := ‚ü®fun X => X.toTop‚ü©\ninstance (X : T0TopCat) : TopologicalSpace X := X.toTop.str\nattribute [instance] T0TopCat.is_t0\n\n\ninstance : Category T0TopCat :=\n  InducedCategory.category (fun X : T0TopCat => X.toTop)", "split": "test"}
{"name": "forget_0", "problem_id": "S_0039_forget_0", "informal_prefix": "", "formal_statement": "def forget_0 : T0TopCat ‚•§ TopCat :=\n  inducedFunctor (fun X : T0TopCat => X.toTop)\n\n\ninstance : forget_0.Faithful  :=\n{ map_injective := by\n    intro X Y f g h\n    simpa [forget_0] using h }\n\n\n@[simp] def of (X : Type u) [TopologicalSpace X] [T0Space X] : T0TopCat :=\n  ‚ü®TopCat.of X, inferInstance‚ü©", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ndef forget_0 : T0TopCat ‚•§ TopCat :=\n  inducedFunctor (fun X : T0TopCat => X.toTop)\n\n\ninstance : forget_0.Faithful  :=\n{ map_injective := by\n    intro X Y f g h\n    simpa [forget_0] using h }\n\n\n@[simp] def of (X : Type u) [TopologicalSpace X] [T0Space X] : T0TopCat :=\n  ‚ü®TopCat.of X, inferInstance‚ü©", "split": "test"}
{"name": "L", "problem_id": "S_0039_L", "informal_prefix": "", "formal_statement": "def L : T0TopCat·µí·µñ ‚•§ Type u :=\n{ obj := fun X => TopologicalSpace.Opens ((X.unop).toTop)\n  map := by\n    intro ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®f‚ü©\n    obtain ‚ü®g‚ü© : (Y.toTop ‚ü∂ X.toTop) := forget_0.map f\n    intro U\n    exact TopologicalSpace.Opens.comap g U\n  map_id := by\n    intro X\n    ext U x\n    rfl\n  map_comp := by\n    intro X Y Z f g\n    ext U x\n    rfl }\n\ninstance : L.Faithful where\n  map_injective {X Y} f g h := by\n    apply Quiver.Hom.unop_inj\n    apply Functor.map_injective T0TopCat.forget_0\n    ext x\n    haveI : T0Space (T0TopCat.forget_0.obj (Opposite.unop X)) := (Opposite.unop X).is_t0\n    apply Inseparable.eq\n    rw [inseparable_iff_forall_isOpen]\n    intro U hU\n    let U_op : TopologicalSpace.Opens (T0TopCat.forget_0.obj (Opposite.unop X)) := ‚ü®U, hU‚ü©\n    have h_eq := congr_fun h U_op\n    dsimp [L] at h_eq\n    have h_set := congr_arg (SetLike.coe) h_eq\n    rw [Set.ext_iff] at h_set\n    exact h_set x\n\nend T0TopCat", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ndef L : T0TopCat·µí·µñ ‚•§ Type u :=\n{ obj := fun X => TopologicalSpace.Opens ((X.unop).toTop)\n  map := by\n    intro ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®f‚ü©\n    obtain ‚ü®g‚ü© : (Y.toTop ‚ü∂ X.toTop) := forget_0.map f\n    intro U\n    exact TopologicalSpace.Opens.comap g U\n  map_id := by\n    intro X\n    ext U x\n    rfl\n  map_comp := by\n    intro X Y Z f g\n    ext U x\n    rfl }\n\ninstance : L.Faithful where\n  map_injective {X Y} f g h := by\n    apply Quiver.Hom.unop_inj\n    apply Functor.map_injective T0TopCat.forget_0\n    ext x\n    haveI : T0Space (T0TopCat.forget_0.obj (Opposite.unop X)) := (Opposite.unop X).is_t0\n    apply Inseparable.eq\n    rw [inseparable_iff_forall_isOpen]\n    intro U hU\n    let U_op : TopologicalSpace.Opens (T0TopCat.forget_0.obj (Opposite.unop X)) := ‚ü®U, hU‚ü©\n    have h_eq := congr_fun h U_op\n    dsimp [L] at h_eq\n    have h_set := congr_arg (SetLike.coe) h_eq\n    rw [Set.ext_iff] at h_set\n    exact h_set x\n\nend T0TopCat", "split": "test"}
{"name": "FrmConcrete", "problem_id": "S_0039_FrmConcrete", "informal_prefix": "", "formal_statement": "def FrmConcrete : ConcreteCat (X := Type u) :=\n{ C := Frm.{u}\n  U := (forgetFrm) }", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ndef FrmConcrete : ConcreteCat (X := Type u) :=\n{ C := Frm.{u}\n  U := (forgetFrm) }", "split": "test"}
{"name": "T0TopCatopConcrete", "problem_id": "S_0039_T0TopCatopConcrete", "informal_prefix": "", "formal_statement": "def T0TopCatopConcrete : ConcreteCat (X := Type u) :=\n{ C := T0TopCat·µí·µñ\n  U := (T0TopCat.L) }", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ndef T0TopCatopConcrete : ConcreteCat (X := Type u) :=\n{ C := T0TopCat·µí·µñ\n  U := (T0TopCat.L) }", "split": "test"}
{"name": "ConcreteFuncsIso", "problem_id": "S_0039_ConcreteFuncsIso", "informal_prefix": "", "formal_statement": "def ConcreteFuncsIso (A B : ConcreteCat (X := Type u)) : Type _ :=\n  { F : A.C ‚•§ B.C // IsConcreteFunc (A := A) (B := B) F }", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ndef ConcreteFuncsIso (A B : ConcreteCat (X := Type u)) : Type _ :=\n  { F : A.C ‚•§ B.C // IsConcreteFunc (A := A) (B := B) F }", "split": "test"}
{"name": "unique_concrete_functors_from_T0TopCatop_to_Frm_iso", "problem_id": "S_0039_unique_concrete_functors_from_T0TopCatop_to_Frm_iso", "informal_prefix": "", "formal_statement": "theorem unique_concrete_functors_from_T0TopCatop_to_Frm_iso :\n    Nat.card (ConcreteFuncsIso T0TopCatConcrete FrmConcrete) = 1 := by\n  sorry\n\nend CAT_statement_S_0039", "lean4_code": "import Mathlib\nopen CategoryTheory Topology\n\ntheorem unique_concrete_functors_from_T0TopCatop_to_Frm_iso :\n    Nat.card (ConcreteFuncsIso T0TopCatConcrete FrmConcrete) = 1 := by\n  sorry\n\nend CAT_statement_S_0039", "split": "test"}
{"name": "funtor_has_quasi_inverse_iff", "problem_id": "S_0006_funtor_has_quasi_inverse_iff", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\n\ntheorem funtor_has_quasi_inverse_iff {C D : Type*} [Category C] [Category D] (F : C ‚•§ D):\n    (‚àÉ G : D ‚•§ C, (Nonempty (Functor.id C ‚âÖ F.comp G)) ‚àß (Nonempty (G.comp F ‚âÖ Functor.id D)))\n    ‚Üî F.IsEquivalence := by\n sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\n\ntheorem funtor_has_quasi_inverse_iff {C D : Type*} [Category C] [Category D] (F : C ‚•§ D):\n    (‚àÉ G : D ‚•§ C, (Nonempty (Functor.id C ‚âÖ F.comp G)) ‚àß (Nonempty (G.comp F ‚âÖ Functor.id D)))\n    ‚Üî F.IsEquivalence := by\n sorry", "split": "test"}
{"name": "PUnit_isSeparator", "problem_id": "S_0043_PUnit_isSeparator", "informal_prefix": "", "formal_statement": "theorem PUnit_isSeparator : IsSeparator (PUnit : Type u) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Function Classical\n\ntheorem PUnit_isSeparator : IsSeparator (PUnit : Type u) := by\n  sorry", "split": "test"}
{"name": "homIntegrandBifunctor", "problem_id": "S_0046_homIntegrandBifunctor", "informal_prefix": "", "formal_statement": "def homIntegrandBifunctor : C·µí·µñ √ó C ‚•§ Type u :=\n  (Functor.prod F.op G) ‚ãô (Functor.hom D)", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef homIntegrandBifunctor : C·µí·µñ √ó C ‚•§ Type u :=\n  (Functor.prod F.op G) ‚ãô (Functor.hom D)", "split": "test"}
{"name": "natTransIsoEnd", "problem_id": "S_0046_natTransIsoEnd", "informal_prefix": "", "formal_statement": "theorem natTransIsoEnd :\n    Nonempty (NatTrans F G ‚âÖ end_ (curryObj (homIntegrandBifunctor F G))) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem natTransIsoEnd :\n    Nonempty (NatTrans F G ‚âÖ end_ (curryObj (homIntegrandBifunctor F G))) := by\n  sorry", "split": "test"}
{"name": "exists_left_adjoint_of_comp_eq", "problem_id": "S_0025_exists_left_adjoint_of_comp_eq", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C D E : Type*} [Category C] [Category D] [Category E]\n\nnamespace CategoryTheory\n\n\nclass Functor.ReflectsSplitEpimorphismsToRegularEpimorphisms (F : Functor C D) : Prop where\n  reflects : ‚àÄ {X Y} {f : X ‚ü∂ Y} [IsSplitEpi (F.map f)], Nonempty (RegularEpi f)\n\nend CategoryTheory\n\nvariable (U : D ‚•§ C) (V : E ‚•§ C) (F : D ‚•§ E)\n\n\ntheorem exists_left_adjoint_of_comp_eq (h : F ‚ãô V = U) (hU : U.IsRightAdjoint) (hV : V.IsRightAdjoint)\n    (hV_refl : V.ReflectsSplitEpimorphismsToRegularEpimorphisms) : F.IsRightAdjoint := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C D E : Type*} [Category C] [Category D] [Category E]\n\nnamespace CategoryTheory\n\n\nclass Functor.ReflectsSplitEpimorphismsToRegularEpimorphisms (F : Functor C D) : Prop where\n  reflects : ‚àÄ {X Y} {f : X ‚ü∂ Y} [IsSplitEpi (F.map f)], Nonempty (RegularEpi f)\n\nend CategoryTheory\n\nvariable (U : D ‚•§ C) (V : E ‚•§ C) (F : D ‚•§ E)\n\n\ntheorem exists_left_adjoint_of_comp_eq (h : F ‚ãô V = U) (hU : U.IsRightAdjoint) (hV : V.IsRightAdjoint)\n    (hV_refl : V.ReflectsSplitEpimorphismsToRegularEpimorphisms) : F.IsRightAdjoint := by\n  sorry", "split": "test"}
{"name": "kleisli_adj_obj", "problem_id": "S_0098_kleisli_adj_obj", "informal_prefix": "", "formal_statement": "def kleisli_adj_obj : AdjCat T :=\n  { D := Kleisli T\n    F := Kleisli.Adjunction.toKleisli T\n    U := Kleisli.Adjunction.fromKleisli T\n    adj := Kleisli.Adjunction.adj T\n    monad_eq :=\n      { hom :=\n          { app := fun X => ùüô (T.obj X)\n            app_Œº (X : C) := by\n              simp\n              rewrite [Kleisli.Adjunction.adj]\n              simp\n              rewrite [Equiv.refl]\n              simp }\n        inv :=\n          { app := fun X => ùüô (T.obj X)\n            app_Œº (X : C) := by\n              simp\n              rewrite [Kleisli.Adjunction.adj]\n              simp\n              rewrite [Equiv.refl]\n              simp } } }", "lean4_code": "import Mathlib\nopen CategoryTheory Monad\n\ndef kleisli_adj_obj : AdjCat T :=\n  { D := Kleisli T\n    F := Kleisli.Adjunction.toKleisli T\n    U := Kleisli.Adjunction.fromKleisli T\n    adj := Kleisli.Adjunction.adj T\n    monad_eq :=\n      { hom :=\n          { app := fun X => ùüô (T.obj X)\n            app_Œº (X : C) := by\n              simp\n              rewrite [Kleisli.Adjunction.adj]\n              simp\n              rewrite [Equiv.refl]\n              simp }\n        inv :=\n          { app := fun X => ùüô (T.obj X)\n            app_Œº (X : C) := by\n              simp\n              rewrite [Kleisli.Adjunction.adj]\n              simp\n              rewrite [Equiv.refl]\n              simp } } }", "split": "test"}
{"name": "kleisli_initial", "problem_id": "S_0098_kleisli_initial", "informal_prefix": "", "formal_statement": "theorem kleisli_initial : Nonempty (Limits.IsInitial (kleisli_adj_obj T)) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Monad\n\ntheorem kleisli_initial : Nonempty (Limits.IsInitial (kleisli_adj_obj T)) := by\n  sorry", "split": "test"}
{"name": "eilenberg_moore_adj_obj", "problem_id": "S_0098_eilenberg_moore_adj_obj", "informal_prefix": "", "formal_statement": "def eilenberg_moore_adj_obj : AdjCat T :=\n  { D := T.Algebra\n    F := Monad.free T\n    U := Monad.forget T\n    adj := Monad.adj T\n    monad_eq :=\n      { hom := { app := fun X => ùüô (T.obj X) }\n        inv := { app := fun X => ùüô (T.obj X) } } }", "lean4_code": "import Mathlib\nopen CategoryTheory Monad\n\ndef eilenberg_moore_adj_obj : AdjCat T :=\n  { D := T.Algebra\n    F := Monad.free T\n    U := Monad.forget T\n    adj := Monad.adj T\n    monad_eq :=\n      { hom := { app := fun X => ùüô (T.obj X) }\n        inv := { app := fun X => ùüô (T.obj X) } } }", "split": "test"}
{"name": "eilenberg_moore_terminal", "problem_id": "S_0098_eilenberg_moore_terminal", "informal_prefix": "", "formal_statement": "theorem eilenberg_moore_terminal : Nonempty (Limits.IsTerminal (eilenberg_moore_adj_obj T)) := by\n  sorry\n\nend CAT_statement_S_0098", "lean4_code": "import Mathlib\nopen CategoryTheory Monad\n\ntheorem eilenberg_moore_terminal : Nonempty (Limits.IsTerminal (eilenberg_moore_adj_obj T)) := by\n  sorry\n\nend CAT_statement_S_0098", "split": "test"}
{"name": "fromTerminalFunctor", "problem_id": "S_0004_fromTerminalFunctor", "informal_prefix": "", "formal_statement": "def fromTerminalFunctor : Type u ‚•§ Type u where\n  obj Œ± := PUnit.{u} ‚Üí Œ±\n  map {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) := fun g => f ‚àò g\n  map_id := by\n    intro Œ±\n    funext g x\n    rfl\n  map_comp := by\n    intro Œ± Œ≤ Œ≥ f g\n    funext h x\n    rfl", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef fromTerminalFunctor : Type u ‚•§ Type u where\n  obj Œ± := PUnit.{u} ‚Üí Œ±\n  map {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) := fun g => f ‚àò g\n  map_id := by\n    intro Œ±\n    funext g x\n    rfl\n  map_comp := by\n    intro Œ± Œ≤ Œ≥ f g\n    funext h x\n    rfl", "split": "test"}
{"name": "reflects_limits_iff_reflects_isomorphisms_preserves_limits", "problem_id": "S_0070_reflects_limits_iff_reflects_isomorphisms_preserves_limits", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C]\nvariable {D : Type u'} [Category.{v'} D]\nvariable (U : C ‚•§ D)\n\n\ntheorem reflects_limits_iff_reflects_isomorphisms_preserves_limits\n    [HasLimitsOfSize.{v, v} C]\n    [PreservesLimitsOfSize.{v, v} U]\n    [CategoryTheory.Functor.Faithful U]\n:\n    ReflectsLimitsOfSize.{v, v} U ‚Üî U.ReflectsIsomorphisms := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C]\nvariable {D : Type u'} [Category.{v'} D]\nvariable (U : C ‚•§ D)\n\n\ntheorem reflects_limits_iff_reflects_isomorphisms_preserves_limits\n    [HasLimitsOfSize.{v, v} C]\n    [PreservesLimitsOfSize.{v, v} U]\n    [CategoryTheory.Functor.Faithful U]\n:\n    ReflectsLimitsOfSize.{v, v} U ‚Üî U.ReflectsIsomorphisms := by\n  sorry", "split": "test"}
{"name": "pAdicFunctor", "problem_id": "S_0045_pAdicFunctor", "informal_prefix": "", "formal_statement": "def pAdicFunctor : ‚Ñï·µí·µñ ‚•§ RingCat where\n  obj n := RingCat.of (ZMod (p ^ (unop n)))\n  map {m n} f := RingCat.ofHom <| \n    ZMod.castHom (pow_dvd_pow p (leOfHom f.unop)) (ZMod (p ^ (unop n)))\n  map_id := by\n    intro n\n    ext x\n    simp\n  map_comp := by\n    intro x y z f g\n    ext x\n    simp", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Opposite\n\ndef pAdicFunctor : ‚Ñï·µí·µñ ‚•§ RingCat where\n  obj n := RingCat.of (ZMod (p ^ (unop n)))\n  map {m n} f := RingCat.ofHom <| \n    ZMod.castHom (pow_dvd_pow p (leOfHom f.unop)) (ZMod (p ^ (unop n)))\n  map_id := by\n    intro n\n    ext x\n    simp\n  map_comp := by\n    intro x y z f g\n    ext x\n    simp", "split": "test"}
{"name": "coend_hom_is_trace_of_matrices", "problem_id": "S_0061_coend_hom_is_trace_of_matrices", "informal_prefix": "", "formal_statement": "theorem coend_hom_is_trace_of_matrices\n    (ùïú : Type u) [Field ùïú] :\n    ‚àÄ (F : (ModuleCat ùïú)·µí·µñ ‚•§ ModuleCat ùïú ‚•§ ModuleCat ùïú),\n      (‚àÄ X Y, (F.obj (Opposite.op X)).obj Y ‚âÖ ModuleCat.of ùïú (X ‚Üí‚Çó[ùïú] Y)) ‚Üí\n      ‚àÉ (T : ModuleCat ùïú),\n        (‚àÉ (tr : ‚àÄ X, (F.obj (Opposite.op X)).obj X ‚ü∂ T),\n\n          Nonempty (IsColimit (Cofan.mk T tr))) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem coend_hom_is_trace_of_matrices\n    (ùïú : Type u) [Field ùïú] :\n    ‚àÄ (F : (ModuleCat ùïú)·µí·µñ ‚•§ ModuleCat ùïú ‚•§ ModuleCat ùïú),\n      (‚àÄ X Y, (F.obj (Opposite.op X)).obj Y ‚âÖ ModuleCat.of ùïú (X ‚Üí‚Çó[ùïú] Y)) ‚Üí\n      ‚àÉ (T : ModuleCat ùïú),\n        (‚àÉ (tr : ‚àÄ X, (F.obj (Opposite.op X)).obj X ‚ü∂ T),\n\n          Nonempty (IsColimit (Cofan.mk T tr))) := by\n  sorry", "split": "test"}
{"name": "TopCat_forget_lifts_and_not_reflects_limits", "problem_id": "S_0073_TopCat_forget_lifts_and_not_reflects_limits", "informal_prefix": "", "formal_statement": "theorem TopCat_forget_lifts_and_not_reflects_limits :\n    LiftsLimits (forget TopCat) ‚àß IsEmpty (ReflectsLimits (forget TopCat)):= by\n  sorry\n\nend CAT_statement_S_0073", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem TopCat_forget_lifts_and_not_reflects_limits :\n    LiftsLimits (forget TopCat) ‚àß IsEmpty (ReflectsLimits (forget TopCat)):= by\n  sorry\n\nend CAT_statement_S_0073", "split": "test"}
{"name": "monad_Top_idempotent", "problem_id": "S_0099_monad_Top_idempotent", "informal_prefix": "", "formal_statement": "theorem monad_Top_idempotent : IsIso TopCat.adj‚ÇÅ.toMonad.Œº := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem monad_Top_idempotent : IsIso TopCat.adj‚ÇÅ.toMonad.Œº := by\n  sorry", "split": "test"}
{"name": "has_limits_iff_has_products_and_pullbacks", "problem_id": "S_0051_has_limits_iff_has_products_and_pullbacks", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C]\n\ntheorem has_limits_iff_has_products_and_pullbacks :\n    HasLimitsOfSize.{v, v} C ‚Üî (‚àÄ (J : Type v), HasLimitsOfShape (Discrete J) C) ‚àß HasLimitsOfShape WalkingCospan C := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C]\n\ntheorem has_limits_iff_has_products_and_pullbacks :\n    HasLimitsOfSize.{v, v} C ‚Üî (‚àÄ (J : Type v), HasLimitsOfShape (Discrete J) C) ‚àß HasLimitsOfShape WalkingCospan C := by\n  sorry", "split": "test"}
{"name": "reflective_iff_cocomplete_and_contains_nonempty_of_full_subcategory_CompHaus", "problem_id": "S_0072_reflective_iff_cocomplete_and_contains_nonempty_of_full_subcategory_CompHaus", "informal_prefix": "", "formal_statement": "theorem reflective_iff_cocomplete_and_contains_nonempty_of_full_subcategory_CompHaus :\n    Nonempty (CategoryTheory.Reflective i) ‚Üî\n      (Nonempty (HasColimits D) ‚àß ‚àÉ X : D, Nonempty (i.obj X)) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Topology\n\ntheorem reflective_iff_cocomplete_and_contains_nonempty_of_full_subcategory_CompHaus :\n    Nonempty (CategoryTheory.Reflective i) ‚Üî\n      (Nonempty (HasColimits D) ‚àß ‚àÉ X : D, Nonempty (i.obj X)) := by\n  sorry", "split": "test"}
{"name": "simple_object_end_is_division_ring", "problem_id": "S_0088_simple_object_end_is_division_ring", "informal_prefix": "", "formal_statement": "theorem simple_object_end_is_division_ring\n    (x : ùíú) [Simple x] :\n    Nonempty (DivisionRing (CategoryTheory.End x)) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem simple_object_end_is_division_ring\n    (x : ùíú) [Simple x] :\n    Nonempty (DivisionRing (CategoryTheory.End x)) := by\n  sorry", "split": "test"}
{"name": "IsRealization", "problem_id": "S_0035_IsRealization", "informal_prefix": "", "formal_statement": "def IsRealization (S T : Construct.{u, v}) (F : S.C ‚•§ T.C) : Prop :=\n  F ‚ãô T.U = S.U ‚àß Functor.Full F ‚àß Function.Injective F.obj", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef IsRealization (S T : Construct.{u, v}) (F : S.C ‚•§ T.C) : Prop :=\n  F ‚ãô T.U = S.U ‚àß Functor.Full F ‚àß Function.Injective F.obj", "split": "test"}
{"name": "exists_universal_construct", "problem_id": "S_0035_exists_universal_construct", "informal_prefix": "", "formal_statement": "theorem exists_universal_construct :\n    ‚àÉ (T : Construct.{u, v}), ‚àÄ (S : Construct.{u, v}), ‚àÉ (F : S.C ‚•§ T.C), IsRealization S T F := by\n  sorry\n\nend CAT_statement_S_0035", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem exists_universal_construct :\n    ‚àÉ (T : Construct.{u, v}), ‚àÄ (S : Construct.{u, v}), ‚àÉ (F : S.C ‚•§ T.C), IsRealization S T F := by\n  sorry\n\nend CAT_statement_S_0035", "split": "test"}
{"name": "forget_Top_faithful_not_full", "problem_id": "S_0003_forget_Top_faithful_not_full", "informal_prefix": "", "formal_statement": "theorem forget_Top_faithful_not_full :\n    (forget TopCat).Faithful ‚àß ¬¨ (forget TopCat).Full := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem forget_Top_faithful_not_full :\n    (forget TopCat).Faithful ‚àß ¬¨ (forget TopCat).Full := by\n  sorry", "split": "test"}
{"name": "forget_Grp_faithful_not_full", "problem_id": "S_0003_forget_Grp_faithful_not_full", "informal_prefix": "", "formal_statement": "theorem forget_Grp_faithful_not_full :\n    (forget Grp).Faithful ‚àß ¬¨ (forget Grp).Full := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem forget_Grp_faithful_not_full :\n    (forget Grp).Faithful ‚àß ¬¨ (forget Grp).Full := by\n  sorry", "split": "test"}
{"name": "forget_Ring_Ab_faithful_not_full", "problem_id": "S_0003_forget_Ring_Ab_faithful_not_full", "informal_prefix": "", "formal_statement": "theorem forget_Ring_Ab_faithful_not_full :\n    (forget‚ÇÇ RingCat Ab).Faithful ‚àß ¬¨ (forget‚ÇÇ RingCat Ab).Full := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem forget_Ring_Ab_faithful_not_full :\n    (forget‚ÇÇ RingCat Ab).Faithful ‚àß ¬¨ (forget‚ÇÇ RingCat Ab).Full := by\n  sorry", "split": "test"}
{"name": "IsSemisimple", "problem_id": "S_0087_IsSemisimple", "informal_prefix": "", "formal_statement": "def IsSemisimple (A : Type u) [Category.{v} A] [Abelian A] : Prop :=\n  ‚àÄ (S : ShortComplex A), S.ShortExact ‚Üí Nonempty S.Splitting", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef IsSemisimple (A : Type u) [Category.{v} A] [Abelian A] : Prop :=\n  ‚àÄ (S : ShortComplex A), S.ShortExact ‚Üí Nonempty S.Splitting", "split": "test"}
{"name": "right_adjoint_isEquivalence_iff_left_full_faithful_and_right_conservative", "problem_id": "S_0021_right_adjoint_isEquivalence_iff_left_full_faithful_and_right_conservative", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]\n\ntheorem right_adjoint_isEquivalence_iff_left_full_faithful_and_right_conservative \n    (F : C ‚•§ D) (G : D ‚•§ C) (adj : F ‚ä£ G) :\n    G.IsEquivalence ‚Üî (F.Full ‚àß F.Faithful) ‚àß G.ReflectsIsomorphisms := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]\n\ntheorem right_adjoint_isEquivalence_iff_left_full_faithful_and_right_conservative \n    (F : C ‚•§ D) (G : D ‚•§ C) (adj : F ‚ä£ G) :\n    G.IsEquivalence ‚Üî (F.Full ‚àß F.Faithful) ‚àß G.ReflectsIsomorphisms := by\n  sorry", "split": "test"}
{"name": "lanDiagram", "problem_id": "S_0078_lanDiagram", "informal_prefix": "", "formal_statement": "def lanDiagram (F : C ‚•§ D) : C ‚•§ (D·µí·µñ ‚•§ Type u) := F ‚ãô yoneda\n\n\nnoncomputable def lanPresheaf (F : C ‚•§ D) (œÜ : C·µí·µñ ‚•§ Type u)\n    [HasWeightedColimit œÜ (lanDiagram F)] : D·µí·µñ ‚•§ Type u :=\n  weightedColimit œÜ (lanDiagram F)", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Functor\nopen CategoryTheory Limits Functor\n\ndef lanDiagram (F : C ‚•§ D) : C ‚•§ (D·µí·µñ ‚•§ Type u) := F ‚ãô yoneda\n\n\nnoncomputable def lanPresheaf (F : C ‚•§ D) (œÜ : C·µí·µñ ‚•§ Type u)\n    [HasWeightedColimit œÜ (lanDiagram F)] : D·µí·µñ ‚•§ Type u :=\n  weightedColimit œÜ (lanDiagram F)", "split": "test"}
{"name": "isSindObject_iff_isSindObject_lanPresheaf", "problem_id": "S_0078_isSindObject_iff_isSindObject_lanPresheaf", "informal_prefix": "", "formal_statement": "theorem isSindObject_iff_isSindObject_lanPresheaf\n    (I : C ‚•§ D) [Full I] [Faithful I] (œÜ : C·µí·µñ ‚•§ Type u)\n    [HasWeightedColimit œÜ (lanDiagram I)] :\n    IsSindObject œÜ ‚Üî IsSindObject (lanPresheaf I œÜ) := by\n  sorry\n\nend CAT_statement_S_0078", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Functor\nopen CategoryTheory Limits Functor\n\ntheorem isSindObject_iff_isSindObject_lanPresheaf\n    (I : C ‚•§ D) [Full I] [Faithful I] (œÜ : C·µí·µñ ‚•§ Type u)\n    [HasWeightedColimit œÜ (lanDiagram I)] :\n    IsSindObject œÜ ‚Üî IsSindObject (lanPresheaf I œÜ) := by\n  sorry\n\nend CAT_statement_S_0078", "split": "test"}
{"name": "isCompactObject_iff_finite_type", "problem_id": "S_0050_isCompactObject_iff_finite_type", "informal_prefix": "", "formal_statement": "theorem isCompactObject_iff_finite_type (X : Type u) :\n    PreservesFilteredColimits (coyoneda.obj (Opposite.op X)) ‚Üî Finite X := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem isCompactObject_iff_finite_type (X : Type u) :\n    PreservesFilteredColimits (coyoneda.obj (Opposite.op X)) ‚Üî Finite X := by\n  sorry", "split": "test"}
{"name": "HasCofilteredColimits", "problem_id": "S_0074_HasCofilteredColimits", "informal_prefix": "", "formal_statement": "def HasCofilteredColimits (L : Type u‚ÇÅ) [Category.{v‚ÇÅ} L] : Prop :=\n  ‚àÄ (J : Type w) [SmallCategory J] [IsCofiltered J], HasColimitsOfShape J L", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef HasCofilteredColimits (L : Type u‚ÇÅ) [Category.{v‚ÇÅ} L] : Prop :=\n  ‚àÄ (J : Type w) [SmallCategory J] [IsCofiltered J], HasColimitsOfShape J L", "split": "test"}
{"name": "HasIntersections", "problem_id": "S_0062_HasIntersections", "informal_prefix": "", "formal_statement": "def HasIntersections (C : Type u) [Category.{v} C]: Prop :=\n  ‚àÄ (B : C) (S : Set (Subobject B)),\n    ‚àÉ A : Subobject B, IsIntersectionOf (C := C) (B := B) A S\n\nclass StronglyComplete (C : Type u) [Category.{v} C] : Prop where\n  complete: HasLimits C\n  hasinter: HasIntersections C\n\nclass StronglyCocomplete (C : Type u) [Category.{v} C] : Prop where\n  dual: StronglyComplete (C:=C·µí·µñ)", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef HasIntersections (C : Type u) [Category.{v} C]: Prop :=\n  ‚àÄ (B : C) (S : Set (Subobject B)),\n    ‚àÉ A : Subobject B, IsIntersectionOf (C := C) (B := B) A S\n\nclass StronglyComplete (C : Type u) [Category.{v} C] : Prop where\n  complete: HasLimits C\n  hasinter: HasIntersections C\n\nclass StronglyCocomplete (C : Type u) [Category.{v} C] : Prop where\n  dual: StronglyComplete (C:=C·µí·µñ)", "split": "test"}
{"name": "ModuleCat", "problem_id": "S_0092_ModuleCat", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {R : Type u} [CommRing R]\n\n\ntheorem ModuleCat.forgetReflectsColimits :\n    Nonempty (ReflectsColimits (forget‚ÇÇ (ModuleCat R) AddCommGrp)) :=\n    sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {R : Type u} [CommRing R]\n\n\ntheorem ModuleCat.forgetReflectsColimits :\n    Nonempty (ReflectsColimits (forget‚ÇÇ (ModuleCat R) AddCommGrp)) :=\n    sorry", "split": "test"}
{"name": "PosetConcrete", "problem_id": "S_0014_PosetConcrete", "informal_prefix": "", "formal_statement": "def PosetConcrete : AHS2.ConcreteCat (Type u) where\n  C := PartOrd.{u}\n  cat := inferInstance\n  U := forget PartOrd\n  U_Faithful := inferInstance", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef PosetConcrete : AHS2.ConcreteCat (Type u) where\n  C := PartOrd.{u}\n  cat := inferInstance\n  U := forget PartOrd\n  U_Faithful := inferInstance", "split": "test"}
{"name": "injective_iff_suplattice", "problem_id": "S_0014_injective_iff_suplattice", "informal_prefix": "", "formal_statement": "theorem injective_iff_suplattice (P : PartOrd.{u}) :\n  AHS2.IsInjectiveObj (C := PosetConcrete) P ‚Üî ‚àÄ (s : Set P), ‚àÉ x, IsLUB s x := by\n  sorry\n\nend Poset\n\nend CAT_statement_S_0014", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem injective_iff_suplattice (P : PartOrd.{u}) :\n  AHS2.IsInjectiveObj (C := PosetConcrete) P ‚Üî ‚àÄ (s : Set P), ‚àÉ x, IsLUB s x := by\n  sorry\n\nend Poset\n\nend CAT_statement_S_0014", "split": "test"}
{"name": "regular_epimorphism_not_product_regular_epimorphism", "problem_id": "S_0068_regular_epimorphism_not_product_regular_epimorphism", "informal_prefix": "", "formal_statement": "theorem regular_epimorphism_not_product_regular_epimorphism : ‚àÉ (C : Type (u+1)) (inst : Category C) (c d c' d' : C) (f : c ‚ü∂ d) (g : c' ‚ü∂ d') (inst‚ÇÅ : RegularEpi f) (inst‚ÇÇ : RegularEpi g) (hasProd‚ÇÅ : HasBinaryProduct c c') (hasProd‚ÇÇ : HasBinaryProduct d d'), IsEmpty (RegularEpi (prod.map f g)) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem regular_epimorphism_not_product_regular_epimorphism : ‚àÉ (C : Type (u+1)) (inst : Category C) (c d c' d' : C) (f : c ‚ü∂ d) (g : c' ‚ü∂ d') (inst‚ÇÅ : RegularEpi f) (inst‚ÇÇ : RegularEpi g) (hasProd‚ÇÅ : HasBinaryProduct c c') (hasProd‚ÇÇ : HasBinaryProduct d d'), IsEmpty (RegularEpi (prod.map f g)) := by\n  sorry", "split": "test"}
{"name": "S", "problem_id": "S_0017_S", "informal_prefix": "", "formal_statement": "def S : TopCat.{u} :=\n  letI : TopologicalSpace (Fin 3) := generateFrom {({0, 1} : Set (Fin 3))}\n  TopCat.of (ULift.{u} (Fin 3))", "lean4_code": "import Mathlib\nopen CategoryTheory Limits TopologicalSpace\n\ndef S : TopCat.{u} :=\n  letI : TopologicalSpace (Fin 3) := generateFrom {({0, 1} : Set (Fin 3))}\n  TopCat.of (ULift.{u} (Fin 3))", "split": "test"}
{"name": "TopCatConcrete", "problem_id": "S_0017_TopCatConcrete", "informal_prefix": "", "formal_statement": "def TopCatConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := TopCat.{u}\n  U := forget TopCat}", "lean4_code": "import Mathlib\nopen CategoryTheory Limits TopologicalSpace\n\ndef TopCatConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := TopCat.{u}\n  U := forget TopCat}", "split": "test"}
{"name": "fullyFaithful_iff_of_adjoints", "problem_id": "S_0026_fullyFaithful_iff_of_adjoints", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Functor\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]\nvariable {F : C ‚•§ D} {G : D ‚•§ C} {H : C ‚•§ D}\n\ntheorem fullyFaithful_iff_of_adjoints (hFG : F ‚ä£ G) (hGH : G ‚ä£ H) :\n    (F.Full ‚àß F.Faithful) ‚Üî (H.Full ‚àß H.Faithful) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Functor\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]\nvariable {F : C ‚•§ D} {G : D ‚•§ C} {H : C ‚•§ D}\n\ntheorem fullyFaithful_iff_of_adjoints (hFG : F ‚ä£ G) (hGH : G ‚ä£ H) :\n    (F.Full ‚àß F.Faithful) ‚Üî (H.Full ‚àß H.Faithful) := by\n  sorry", "split": "test"}
{"name": "counitCofork", "problem_id": "S_0100_counitCofork", "informal_prefix": "", "formal_statement": "def counitCofork (d : D) :\n    Cofork (epsFG (F := F) (G := G) adj d) (FGeps (F := F) (G := G) adj d) :=\n  Cofork.ofœÄ (adj.counit.app d) (by\n\n    simp [epsFG, FGeps]\n  )", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef counitCofork (d : D) :\n    Cofork (epsFG (F := F) (G := G) adj d) (FGeps (F := F) (G := G) adj d) :=\n  Cofork.ofœÄ (adj.counit.app d) (by\n\n    simp [epsFG, FGeps]\n  )", "split": "test"}
{"name": "cond1", "problem_id": "S_0100_cond1", "informal_prefix": "", "formal_statement": "def cond1 : Prop :=\n  (K (F := F) (G := G) adj).Full ‚àß (K (F := F) (G := G) adj).Faithful", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef cond1 : Prop :=\n  (K (F := F) (G := G) adj).Full ‚àß (K (F := F) (G := G) adj).Faithful", "split": "test"}
{"name": "cond2", "problem_id": "S_0100_cond2", "informal_prefix": "", "formal_statement": "def cond2 : Prop :=\n  ‚àÄ d : D, Nonempty (IsColimit (counitCofork (F := F) (G := G) adj d))", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef cond2 : Prop :=\n  ‚àÄ d : D, Nonempty (IsColimit (counitCofork (F := F) (G := G) adj d))", "split": "test"}
{"name": "cond3", "problem_id": "S_0100_cond3", "informal_prefix": "", "formal_statement": "def cond3 : Prop :=\n  ReflectsSplitEpiToRegularEpi' (G := G)", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef cond3 : Prop :=\n  ReflectsSplitEpiToRegularEpi' (G := G)", "split": "test"}
{"name": "K_fullyFaithful_tfae", "problem_id": "S_0100_K_fullyFaithful_tfae", "informal_prefix": "", "formal_statement": "theorem K_fullyFaithful_tfae :\n    List.TFAE\n      [cond1 (F := F) (G := G) adj,\n       cond2 (F := F) (G := G) adj,\n       cond3 (G := G)] := by\n  sorry\n\nend CAT_statement_S0100", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem K_fullyFaithful_tfae :\n    List.TFAE\n      [cond1 (F := F) (G := G) adj,\n       cond2 (F := F) (G := G) adj,\n       cond3 (G := G)] := by\n  sorry\n\nend CAT_statement_S0100", "split": "test"}
{"name": "exists_leftAdjoint_unitFunctor", "problem_id": "S_0029_exists_leftAdjoint_unitFunctor", "informal_prefix": "", "formal_statement": "theorem exists_leftAdjoint_unitFunctor :\n    ‚àÉ (left : Grp.{u} ‚•§ RingCat.{u}), Nonempty (left ‚ä£ RingCat.units.{u}) := by\n    sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem exists_leftAdjoint_unitFunctor :\n    ‚àÉ (left : Grp.{u} ‚•§ RingCat.{u}), Nonempty (left ‚ä£ RingCat.units.{u}) := by\n    sorry", "split": "test"}
{"name": "exists_sequence_of_distinct_adjoints_nat", "problem_id": "S_0028_exists_sequence_of_distinct_adjoints_nat", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\ntheorem exists_sequence_of_distinct_adjoints_nat :\n    ‚àÉ G : ‚Ñï ‚Üí (‚Ñï ‚•§ ‚Ñï),\n      Function.Injective G ‚àß\n      (‚àÄ x, (G 0).obj x = x + 1) ‚àß\n      (‚àÄ n, Nonempty (G (n + 1) ‚ä£ G n)) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\ntheorem exists_sequence_of_distinct_adjoints_nat :\n    ‚àÉ G : ‚Ñï ‚Üí (‚Ñï ‚•§ ‚Ñï),\n      Function.Injective G ‚àß\n      (‚àÄ x, (G 0).obj x = x + 1) ‚àß\n      (‚àÄ n, Nonempty (G (n + 1) ‚ä£ G n)) := by\n  sorry", "split": "test"}
{"name": "torsionFree_iff_isFilteredColimit_free", "problem_id": "S_0069_torsionFree_iff_isFilteredColimit_free", "informal_prefix": "", "formal_statement": "theorem torsionFree_iff_isFilteredColimit_free\n    (A : ModuleCat ‚Ñ§) :\n    NoZeroSMulDivisors ‚Ñ§ A ‚Üî\n      ‚àÉ (J : Type) (_ : SmallCategory J) (_ : IsFiltered J)\n        (F : J ‚•§ ModuleCat ‚Ñ§),\n        (‚àÄ j : J, Module.Free ‚Ñ§ (F.obj j)) ‚àß\n        Nonempty (A ‚âÖ colimit F) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem torsionFree_iff_isFilteredColimit_free\n    (A : ModuleCat ‚Ñ§) :\n    NoZeroSMulDivisors ‚Ñ§ A ‚Üî\n      ‚àÉ (J : Type) (_ : SmallCategory J) (_ : IsFiltered J)\n        (F : J ‚•§ ModuleCat ‚Ñ§),\n        (‚àÄ j : J, Module.Free ‚Ñ§ (F.obj j)) ‚àß\n        Nonempty (A ‚âÖ colimit F) := by\n  sorry", "split": "test"}
{"name": "cocomplete_iff_hasCoequalizers_of_monadic", "problem_id": "S_0093_cocomplete_iff_hasCoequalizers_of_monadic", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nuniverse uC uD vC vD w w'\n\nvariable {C : Type uC} [Category.{vC} C]\nvariable {D : Type uD} [Category.{vD} D]\nvariable (G : D ‚•§ C)\n\ntheorem cocomplete_iff_hasCoequalizers_of_monadic\n  [HasColimitsOfSize.{w, w'} C] [MonadicRightAdjoint G] :\n    HasColimitsOfSize.{w, w'} D ‚Üî HasCoequalizers D := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nuniverse uC uD vC vD w w'\n\nvariable {C : Type uC} [Category.{vC} C]\nvariable {D : Type uD} [Category.{vD} D]\nvariable (G : D ‚•§ C)\n\ntheorem cocomplete_iff_hasCoequalizers_of_monadic\n  [HasColimitsOfSize.{w, w'} C] [MonadicRightAdjoint G] :\n    HasColimitsOfSize.{w, w'} D ‚Üî HasCoequalizers D := by\n  sorry", "split": "test"}
{"name": "monadicOfConservativePreservesCoequalizers", "problem_id": "S_0095_monadicOfConservativePreservesCoequalizers", "informal_prefix": "", "formal_statement": "theorem monadicOfConservativePreservesCoequalizers :\n    Nonempty (MonadicRightAdjoint G) := by\n    sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem monadicOfConservativePreservesCoequalizers :\n    Nonempty (MonadicRightAdjoint G) := by\n    sorry", "split": "test"}
{"name": "ring_hom_induced_functor_has_adjoints", "problem_id": "S_0023_ring_hom_induced_functor_has_adjoints", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\ntheorem ring_hom_induced_functor_has_adjoints\n    {A B : RingCat} (œÜ : A ‚ü∂ B) :\n    ‚àÉ (œÜ_pull : ModuleCat B ‚•§ ModuleCat A)\n      (œÜ_push : ModuleCat A ‚•§ ModuleCat B)\n      (œÜ_coind : ModuleCat A ‚•§ ModuleCat B),\n      Nonempty (Adjunction œÜ_push œÜ_pull) ‚àß Nonempty (Adjunction œÜ_pull œÜ_coind) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\ntheorem ring_hom_induced_functor_has_adjoints\n    {A B : RingCat} (œÜ : A ‚ü∂ B) :\n    ‚àÉ (œÜ_pull : ModuleCat B ‚•§ ModuleCat A)\n      (œÜ_push : ModuleCat A ‚•§ ModuleCat B)\n      (œÜ_coind : ModuleCat A ‚•§ ModuleCat B),\n      Nonempty (Adjunction œÜ_push œÜ_pull) ‚àß Nonempty (Adjunction œÜ_pull œÜ_coind) := by\n  sorry", "split": "test"}
{"name": "binormal_mono_simple_iff_epi_simple", "problem_id": "S_0090_binormal_mono_simple_iff_epi_simple", "informal_prefix": "", "formal_statement": "theorem binormal_mono_simple_iff_epi_simple (x : A) :\n    (‚àÄ (y : A) (f : y ‚ü∂ x) [Mono f], f = 0 ‚à® IsIso f) ‚Üî\n    (‚àÄ (y : A) (g : x ‚ü∂ y) [Epi g], g = 0 ‚à® IsIso g) := by\n    sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem binormal_mono_simple_iff_epi_simple (x : A) :\n    (‚àÄ (y : A) (f : y ‚ü∂ x) [Mono f], f = 0 ‚à® IsIso f) ‚Üî\n    (‚àÄ (y : A) (g : x ‚ü∂ y) [Epi g], g = 0 ‚à® IsIso g) := by\n    sorry", "split": "test"}
{"name": "karoubi_universal_property", "problem_id": "S_0007_karoubi_universal_property", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D]\n\ntheorem karoubi_universal_property [IsIdempotentComplete D] (F : C ‚•§ D) :\n    ‚àÉ! (F' : (Idempotents.Karoubi C) ‚•§ D), (Idempotents.toKaroubi C) ‚ãô F' = F := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D]\n\ntheorem karoubi_universal_property [IsIdempotentComplete D] (F : C ‚•§ D) :\n    ‚àÉ! (F' : (Idempotents.Karoubi C) ‚•§ D), (Idempotents.toKaroubi C) ‚ãô F' = F := by\n  sorry", "split": "test"}
{"name": "gelfandDuality", "problem_id": "S_0013_gelfandDuality", "informal_prefix": "", "formal_statement": "theorem gelfandDuality : Nonempty (CompHaus.{u} ‚âå (CommCStarAlgCat.{u})·µí·µñ) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem gelfandDuality : Nonempty (CompHaus.{u} ‚âå (CommCStarAlgCat.{u})·µí·µñ) := by\n  sorry", "split": "test"}
{"name": "isRecObject_yoneda", "problem_id": "S_0077_isRecObject_yoneda", "informal_prefix": "", "formal_statement": "theorem isRecObject_yoneda (X : C) :\n    IsRecObject (C := C) ((yoneda : C ‚•§ Psh C).obj X) :=\n  ‚ü®‚ü®RecObjectPresentation.ofYoneda (C := C) X‚ü©‚ü©", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\nopen Limits Functor\nopen Limits\nopen Limits Functor\nopen Limits\nopen CategoryTheory\n\ntheorem isRecObject_yoneda (X : C) :\n    IsRecObject (C := C) ((yoneda : C ‚•§ Psh C).obj X) :=\n  ‚ü®‚ü®RecObjectPresentation.ofYoneda (C := C) X‚ü©‚ü©", "split": "test"}
{"name": "Rec", "problem_id": "S_0077_Rec", "informal_prefix": "", "formal_statement": "def Rec : Type (max u (v + 1)) :=\n  ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C)))\n\nnoncomputable instance : Category.{max u v} (Rec C) :=\n  inferInstanceAs <| Category.{max u v}\n    (ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C))))\n\n\nnoncomputable def Rec.equivalence :\n    Rec C ‚âå ObjectProperty.FullSubcategory (IsRecObject (C := C)) :=\n  (ShrinkHoms.equivalence _).symm\n\nend CategoryTheory\n\n\nnamespace CategoryTheory.Limits\nopen Limits Functor\nvariable {C : Type u} [Category.{v} C]\n\n\nstructure SindObjectPresentation (A : C·µí·µñ ‚•§ Type v) where\n\n  I : Type v\n\n  [‚Ñê : SmallCategory I]\n  [hI : IsSifted I]\n\n  F : I ‚•§ C\n\n  Œπ : F ‚ãô yoneda ‚ü∂ (Functor.const I).obj A\n\n  isColimit : IsColimit (Cocone.mk A Œπ)\n\nnamespace SindObjectPresentation\n\n\n@[simps]", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\nopen Limits Functor\nopen Limits\nopen Limits Functor\nopen Limits\nopen CategoryTheory\n\ndef Rec : Type (max u (v + 1)) :=\n  ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C)))\n\nnoncomputable instance : Category.{max u v} (Rec C) :=\n  inferInstanceAs <| Category.{max u v}\n    (ShrinkHoms (ObjectProperty.FullSubcategory (IsRecObject (C := C))))\n\n\nnoncomputable def Rec.equivalence :\n    Rec C ‚âå ObjectProperty.FullSubcategory (IsRecObject (C := C)) :=\n  (ShrinkHoms.equivalence _).symm\n\nend CategoryTheory\n\n\nnamespace CategoryTheory.Limits\nopen Limits Functor\nvariable {C : Type u} [Category.{v} C]\n\n\nstructure SindObjectPresentation (A : C·µí·µñ ‚•§ Type v) where\n\n  I : Type v\n\n  [‚Ñê : SmallCategory I]\n  [hI : IsSifted I]\n\n  F : I ‚•§ C\n\n  Œπ : F ‚ãô yoneda ‚ü∂ (Functor.const I).obj A\n\n  isColimit : IsColimit (Cocone.mk A Œπ)\n\nnamespace SindObjectPresentation\n\n\n@[simps]", "split": "test"}
{"name": "yoneda", "problem_id": "S_0077_yoneda", "informal_prefix": "", "formal_statement": "def yoneda (X : C) : SindObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  Œπ := { app := fun _ => ùüô _ }\n  isColimit :=\n    { desc := fun s => s.Œπ.app ‚ü®PUnit.unit‚ü©\n      uniq := fun _ _ h => h ‚ü®PUnit.unit‚ü© }\n\nend SindObjectPresentation\n\n\nstructure IsSindObject (A : C·µí·µñ ‚•§ Type v) : Prop where\n  mk' :: nonempty_presentation : Nonempty (SindObjectPresentation A)", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\nopen Limits Functor\nopen Limits\nopen Limits Functor\nopen Limits\nopen CategoryTheory\n\ndef yoneda (X : C) : SindObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  Œπ := { app := fun _ => ùüô _ }\n  isColimit :=\n    { desc := fun s => s.Œπ.app ‚ü®PUnit.unit‚ü©\n      uniq := fun _ _ h => h ‚ü®PUnit.unit‚ü© }\n\nend SindObjectPresentation\n\n\nstructure IsSindObject (A : C·µí·µñ ‚•§ Type v) : Prop where\n  mk' :: nonempty_presentation : Nonempty (SindObjectPresentation A)", "split": "test"}
{"name": "isSindObject_yoneda", "problem_id": "S_0077_isSindObject_yoneda", "informal_prefix": "", "formal_statement": "theorem isSindObject_yoneda (X : C) : IsSindObject (yoneda.obj X) :=\n  .mk <| SindObjectPresentation.yoneda X\n\nend CategoryTheory.Limits\n\n\nnamespace CategoryTheory\n\nopen Limits\n\nvariable {C : Type u} [Category.{v} C]\n\nvariable (C)  in", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\nopen Limits Functor\nopen Limits\nopen Limits Functor\nopen Limits\nopen CategoryTheory\n\ntheorem isSindObject_yoneda (X : C) : IsSindObject (yoneda.obj X) :=\n  .mk <| SindObjectPresentation.yoneda X\n\nend CategoryTheory.Limits\n\n\nnamespace CategoryTheory\n\nopen Limits\n\nvariable {C : Type u} [Category.{v} C]\n\nvariable (C)  in", "split": "test"}
{"name": "Sind", "problem_id": "S_0077_Sind", "informal_prefix": "", "formal_statement": "def Sind : Type (max u (v + 1)) :=\n  ShrinkHoms (ObjectProperty.FullSubcategory (IsSindObject (C := C)))\n\nnoncomputable instance : Category.{max u v} (Sind C) :=\n  inferInstanceAs <| Category.{max u v}\n    (ShrinkHoms (ObjectProperty.FullSubcategory (IsSindObject (C := C))))\n\nvariable (C) in\n\nnoncomputable def Sind.equivalence :\n    Sind C ‚âå ObjectProperty.FullSubcategory (IsSindObject (C := C)) :=\n  (ShrinkHoms.equivalence _).symm\n\nend CategoryTheory\n\n\nopen CategoryTheory", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\nopen Limits Functor\nopen Limits\nopen Limits Functor\nopen Limits\nopen CategoryTheory\n\ndef Sind : Type (max u (v + 1)) :=\n  ShrinkHoms (ObjectProperty.FullSubcategory (IsSindObject (C := C)))\n\nnoncomputable instance : Category.{max u v} (Sind C) :=\n  inferInstanceAs <| Category.{max u v}\n    (ShrinkHoms (ObjectProperty.FullSubcategory (IsSindObject (C := C))))\n\nvariable (C) in\n\nnoncomputable def Sind.equivalence :\n    Sind C ‚âå ObjectProperty.FullSubcategory (IsSindObject (C := C)) :=\n  (ShrinkHoms.equivalence _).symm\n\nend CategoryTheory\n\n\nopen CategoryTheory", "split": "test"}
{"name": "schur_simple_monosimple_and_episimple", "problem_id": "S_0089_schur_simple_monosimple_and_episimple", "informal_prefix": "", "formal_statement": "theorem schur_simple_monosimple_and_episimple\n    (x : A) [NoZeroDivisors (End x)] :\n    (‚àÄ (y : A) (f : y ‚ü∂ x) [Mono f], f = 0 ‚à® IsIso f) ‚àß\n    (‚àÄ (y : A) (g : x ‚ü∂ y) [Epi g], g = 0 ‚à® IsIso g) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem schur_simple_monosimple_and_episimple\n    (x : A) [NoZeroDivisors (End x)] :\n    (‚àÄ (y : A) (f : y ‚ü∂ x) [Mono f], f = 0 ‚à® IsIso f) ‚àß\n    (‚àÄ (y : A) (g : x ‚ü∂ y) [Epi g], g = 0 ‚à® IsIso g) := by\n  sorry", "split": "test"}
{"name": "IsConcretizable", "problem_id": "S_0038_IsConcretizable", "informal_prefix": "", "formal_statement": "def IsConcretizable (X : Type v) [Category X] (D: Type u) [Category D] : Prop :=\n  ‚àÉ (U : D ‚•§ X), U.Faithful\n\nvariable (C)\n\nclass RegularWellPowered : Prop where\n  regularSubobject_small : ‚àÄ (X : C), Small.{v} { P : Subobject X //  Nonempty (RegularMono P.arrow) }", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ndef IsConcretizable (X : Type v) [Category X] (D: Type u) [Category D] : Prop :=\n  ‚àÉ (U : D ‚•§ X), U.Faithful\n\nvariable (C)\n\nclass RegularWellPowered : Prop where\n  regularSubobject_small : ‚àÄ (X : C), Small.{v} { P : Subobject X //  Nonempty (RegularMono P.arrow) }", "split": "test"}
{"name": "concretizable_iff_regular_wellpowered", "problem_id": "S_0038_concretizable_iff_regular_wellpowered", "informal_prefix": "", "formal_statement": "theorem concretizable_iff_regular_wellpowered :\n    IsConcretizable (Type u) C ‚Üî RegularWellPowered C := by\n  sorry\n\nend CAT_statement_S_0038", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem concretizable_iff_regular_wellpowered :\n    IsConcretizable (Type u) C ‚Üî RegularWellPowered C := by\n  sorry\n\nend CAT_statement_S_0038", "split": "test"}
{"name": "IsFreeObject", "problem_id": "S_0034_IsFreeObject", "informal_prefix": "", "formal_statement": "def IsFreeObject (U : C ‚•§ Type v) (d : C) (I : Type v) : Prop :=\n  ‚àÉ (Œ∑ : I ‚ü∂ U.obj d), ‚àÄ {y : C} (f : I ‚ü∂ U.obj y), ‚àÉ! (g : d ‚ü∂ y), U.map g ‚àò Œ∑ = f", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Functor Opposite\n\ndef IsFreeObject (U : C ‚•§ Type v) (d : C) (I : Type v) : Prop :=\n  ‚àÉ (Œ∑ : I ‚ü∂ U.obj d), ‚àÄ {y : C} (f : I ‚ü∂ U.obj y), ‚àÉ! (g : d ‚ü∂ y), U.map g ‚àò Œ∑ = f", "split": "test"}
{"name": "IsCopower", "problem_id": "S_0034_IsCopower", "informal_prefix": "", "formal_statement": "def IsCopower (x d : C) (I : Type v) : Prop :=\n  ‚àÉ (Œπ : I ‚Üí (x ‚ü∂ d)), Nonempty (IsColimit (Cofan.mk d Œπ))", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Functor Opposite\n\ndef IsCopower (x d : C) (I : Type v) : Prop :=\n  ‚àÉ (Œπ : I ‚Üí (x ‚ü∂ d)), Nonempty (IsColimit (Cofan.mk d Œπ))", "split": "test"}
{"name": "free_iff_copower_of_representable", "problem_id": "S_0034_free_iff_copower_of_representable", "informal_prefix": "", "formal_statement": "theorem free_iff_copower_of_representable\n    (U : C ‚•§ Type v) [Faithful U]\n    (x : C) (hU : U ‚âÖ coyoneda.obj (op x))\n    (I : Type v) (d : C) :\n    IsFreeObject U d I ‚Üî IsCopower x d I := by\n  sorry\n\nend CAT_statement_S_0034", "lean4_code": "import Mathlib\nopen CategoryTheory Limits Functor Opposite\n\ntheorem free_iff_copower_of_representable\n    (U : C ‚•§ Type v) [Faithful U]\n    (x : C) (hU : U ‚âÖ coyoneda.obj (op x))\n    (I : Type v) (d : C) :\n    IsFreeObject U d I ‚Üî IsCopower x d I := by\n  sorry\n\nend CAT_statement_S_0034", "split": "test"}
{"name": "exists_not_reflective", "problem_id": "S_0030_exists_not_reflective", "informal_prefix": "", "formal_statement": "theorem exists_not_reflective :\n    ‚àÉ (E C D : Type u)\n    (_ : Category.{v} E) (_ : Category.{v} C) (_ : Category.{v} D) (i : C ‚•§ D)\n    (_ : Faithful i) (j : D ‚•§ E) (_ : Faithful j),\n    IsEmpty (Reflective2 i) ‚àß Nonempty (Reflective2 (i ‚ãô j)) := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Functor\nopen Category Adjunction\n\ntheorem exists_not_reflective :\n    ‚àÉ (E C D : Type u)\n    (_ : Category.{v} E) (_ : Category.{v} C) (_ : Category.{v} D) (i : C ‚•§ D)\n    (_ : Faithful i) (j : D ‚•§ E) (_ : Faithful j),\n    IsEmpty (Reflective2 i) ‚àß Nonempty (Reflective2 (i ‚ãô j)) := by\n  sorry", "split": "test"}
{"name": "exists_epic_not_surjective_in_Ring", "problem_id": "S_0009_exists_epic_not_surjective_in_Ring", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory\n\ntheorem exists_epic_not_surjective_in_Ring :\n    ‚àÉ (A B : RingCat) (f : A ‚ü∂ B), Epi f ‚àß ¬¨ Function.Surjective f := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory\n\ntheorem exists_epic_not_surjective_in_Ring :\n    ‚àÉ (A B : RingCat) (f : A ‚ü∂ B), Epi f ‚àß ¬¨ Function.Surjective f := by\n  sorry", "split": "test"}
{"name": "CompHausConcrete", "problem_id": "S_0018_CompHausConcrete", "informal_prefix": "", "formal_statement": "def CompHausConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := CompHaus.{u}\n  U := forget CompHaus}", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef CompHausConcrete : AHS.ConcreteCat (X := Type u) :=\n{ C := CompHaus.{u}\n  U := forget CompHaus}", "split": "test"}
{"name": "reflectsIsomorphisms_of_reflects_equalizers", "problem_id": "S_0057_reflectsIsomorphisms_of_reflects_equalizers", "informal_prefix": "", "formal_statement": "theorem reflectsIsomorphisms_of_reflects_equalizers (F : C ‚•§ D)\n    [ReflectsLimitsOfShape WalkingParallelPair F] : F.ReflectsIsomorphisms := by\n  sorry", "lean4_code": "import Mathlib\nopen CategoryTheory Limits\n\ntheorem reflectsIsomorphisms_of_reflects_equalizers (F : C ‚•§ D)\n    [ReflectsLimitsOfShape WalkingParallelPair F] : F.ReflectsIsomorphisms := by\n  sorry", "split": "test"}
{"name": "hasLeftAdjoint_iff_ran_id_preserved", "problem_id": "S_0056_hasLeftAdjoint_iff_ran_id_preserved", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Functor\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]\n\ntheorem hasLeftAdjoint_iff_ran_id_preserved (G : D ‚•§ C) :\n    G.IsRightAdjoint ‚Üî \n    ‚àÉ (R : C ‚•§ D) (Œ± : G ‚ãô R ‚ü∂ ùü≠ D), \n      R.IsRightKanExtension Œ± ‚àß \n      (R ‚ãô G).IsRightKanExtension ((associator G R G).inv ‚â´ whiskerRight Œ± G ‚â´ (leftUnitor G).hom) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Functor\n\nvariable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]\n\ntheorem hasLeftAdjoint_iff_ran_id_preserved (G : D ‚•§ C) :\n    G.IsRightAdjoint ‚Üî \n    ‚àÉ (R : C ‚•§ D) (Œ± : G ‚ãô R ‚ü∂ ùü≠ D), \n      R.IsRightKanExtension Œ± ‚àß \n      (R ‚ãô G).IsRightKanExtension ((associator G R G).inv ‚â´ whiskerRight Œ± G ‚â´ (leftUnitor G).hom) := by\n  sorry", "split": "test"}
{"name": "IsUniversalArrowOver", "problem_id": "S_0040_IsUniversalArrowOver", "informal_prefix": "", "formal_statement": "def IsUniversalArrowOver (x : X) {C : ConcreteCat (X := X)}  (u : StructuredArrowOver x C) : Prop :=\n  ‚àÄ (v : StructuredArrowOver x C),\n    ‚àÉ! (g : u.right ‚ü∂ v.right), u.hom ‚â´ C.U.map g = v.hom", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef IsUniversalArrowOver (x : X) {C : ConcreteCat (X := X)}  (u : StructuredArrowOver x C) : Prop :=\n  ‚àÄ (v : StructuredArrowOver x C),\n    ‚àÉ! (g : u.right ‚ü∂ v.right), u.hom ‚â´ C.U.map g = v.hom", "split": "test"}
{"name": "IsFreeObjectOver", "problem_id": "S_0040_IsFreeObjectOver", "informal_prefix": "", "formal_statement": "def IsFreeObjectOver (x : X) {C : ConcreteCat (X := X)} (z : C.C) : Prop :=\n  ‚àÉ (f : StructuredArrowOver x C), f.right = z ‚àß IsUniversalArrowOver (x := x) (C := C) f", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef IsFreeObjectOver (x : X) {C : ConcreteCat (X := X)} (z : C.C) : Prop :=\n  ‚àÉ (f : StructuredArrowOver x C), f.right = z ‚àß IsUniversalArrowOver (x := x) (C := C) f", "split": "test"}
{"name": "HasFreeObject", "problem_id": "S_0040_HasFreeObject", "informal_prefix": "", "formal_statement": "def HasFreeObject (C : ConcreteCat (X := X)) : Prop :=\n  ‚àÄ (x : X), ‚àÉ (z : C.C), IsFreeObjectOver (x := x) (z := z)\n\n\nstructure SupLatCat where\n  carrier : Type u\n  [inst : CompleteSemilatticeSup carrier]\n\nattribute [instance] SupLatCat.inst\n\ninstance : CoeSort SupLatCat (Type u) := ‚ü®SupLatCat.carrier‚ü©", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef HasFreeObject (C : ConcreteCat (X := X)) : Prop :=\n  ‚àÄ (x : X), ‚àÉ (z : C.C), IsFreeObjectOver (x := x) (z := z)\n\n\nstructure SupLatCat where\n  carrier : Type u\n  [inst : CompleteSemilatticeSup carrier]\n\nattribute [instance] SupLatCat.inst\n\ninstance : CoeSort SupLatCat (Type u) := ‚ü®SupLatCat.carrier‚ü©", "split": "test"}
{"name": "of", "problem_id": "S_0040_of", "informal_prefix": "", "formal_statement": "def of (Œ± : Type u) [CompleteSemilatticeSup Œ±] : SupLatCat := ‚ü®Œ±‚ü©\n\n\nstructure Hom (A B : SupLatCat.{u}) where\n  toFun : A ‚Üí B\n  map_sSup' : ‚àÄ s : Set A, toFun (sSup s) = sSup (toFun '' s)\n\ninstance (A B : SupLatCat) : CoeFun (Hom A B) (fun _ => A ‚Üí B) := ‚ü®Hom.toFun‚ü©\n\n@[simp] lemma Hom.map_sSup {A B : SupLatCat} (f : Hom A B) (s : Set A) :\n    f (sSup s) = sSup (f '' s) :=\n  f.map_sSup' s\n\n@[ext] lemma Hom.ext {A B : SupLatCat} {f g : Hom A B}\n    (h : ‚àÄ a, f a = g a) : f = g := by\n  cases f with\n  | mk fto fmap =>\n    cases g with\n    | mk gto gmap =>\n      have hto : fto = gto := funext (by intro a; exact h a)\n      cases hto\n      have : fmap = gmap := by\n        apply Subsingleton.elim\n      cases this\n      rfl", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef of (Œ± : Type u) [CompleteSemilatticeSup Œ±] : SupLatCat := ‚ü®Œ±‚ü©\n\n\nstructure Hom (A B : SupLatCat.{u}) where\n  toFun : A ‚Üí B\n  map_sSup' : ‚àÄ s : Set A, toFun (sSup s) = sSup (toFun '' s)\n\ninstance (A B : SupLatCat) : CoeFun (Hom A B) (fun _ => A ‚Üí B) := ‚ü®Hom.toFun‚ü©\n\n@[simp] lemma Hom.map_sSup {A B : SupLatCat} (f : Hom A B) (s : Set A) :\n    f (sSup s) = sSup (f '' s) :=\n  f.map_sSup' s\n\n@[ext] lemma Hom.ext {A B : SupLatCat} {f g : Hom A B}\n    (h : ‚àÄ a, f a = g a) : f = g := by\n  cases f with\n  | mk fto fmap =>\n    cases g with\n    | mk gto gmap =>\n      have hto : fto = gto := funext (by intro a; exact h a)\n      cases hto\n      have : fmap = gmap := by\n        apply Subsingleton.elim\n      cases this\n      rfl", "split": "test"}
{"name": "id", "problem_id": "S_0040_id", "informal_prefix": "", "formal_statement": "def id (A : SupLatCat) : Hom A A :=\n{ toFun := (_root_.id : A ‚Üí A)\n  map_sSup' := by\n    intro s\n    simp }", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef id (A : SupLatCat) : Hom A A :=\n{ toFun := (_root_.id : A ‚Üí A)\n  map_sSup' := by\n    intro s\n    simp }", "split": "test"}
{"name": "forget", "problem_id": "S_0040_forget", "informal_prefix": "", "formal_statement": "def forget : SupLatCat ‚•§ Type u :=\n{ obj := fun A => A.carrier\n  map := fun {X Y} (f : X ‚ü∂ Y) => f.toFun\n  map_id := by intro A; rfl\n  map_comp := by intro A B C f g; rfl }\n\n\ninstance : forget.Faithful  where\n  map_injective := by\n    intro X Y f g h\n    apply Hom.ext\n    intro x\n    simpa using congrArg (fun k => k x) h", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef forget : SupLatCat ‚•§ Type u :=\n{ obj := fun A => A.carrier\n  map := fun {X Y} (f : X ‚ü∂ Y) => f.toFun\n  map_id := by intro A; rfl\n  map_comp := by intro A B C f g; rfl }\n\n\ninstance : forget.Faithful  where\n  map_injective := by\n    intro X Y f g h\n    apply Hom.ext\n    intro x\n    simpa using congrArg (fun k => k x) h", "split": "test"}
{"name": "SupLatCatConcrete", "problem_id": "S_0040_SupLatCatConcrete", "informal_prefix": "", "formal_statement": "def SupLatCatConcrete : ConcreteCat (X := Type u) :=\n{ C := SupLatCat.{u}\n  U := (forget) }", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef SupLatCatConcrete : ConcreteCat (X := Type u) :=\n{ C := SupLatCat.{u}\n  U := (forget) }", "split": "test"}
{"name": "SupLat_Has_Free_Object", "problem_id": "S_0040_SupLat_Has_Free_Object", "informal_prefix": "", "formal_statement": "theorem SupLat_Has_Free_Object :\n    HasFreeObject SupLatCatConcrete:= by\n  sorry\n\n\nend CAT_statement_S_0040", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem SupLat_Has_Free_Object :\n    HasFreeObject SupLatCatConcrete:= by\n  sorry\n\n\nend CAT_statement_S_0040", "split": "test"}
{"name": "has_initial_of_locally_small_complete_coseparating", "problem_id": "S_0060_has_initial_of_locally_small_complete_coseparating", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\ntheorem has_initial_of_locally_small_complete_coseparating {‚Ñ¨ : Type u} [Category.{v} ‚Ñ¨] \n    [LocallySmall.{w} ‚Ñ¨] [HasLimitsOfSize.{w, w} ‚Ñ¨] {S : Set ‚Ñ¨} [Small.{w} S] \n    (hS : IsCoseparating S) (h : ‚àÄ (A : ‚Ñ¨), ‚àÄ (s : Set (Subobject A)), ‚àÉ (f : Subobject A), \n    IsGLB s f) : HasInitial ‚Ñ¨ := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\ntheorem has_initial_of_locally_small_complete_coseparating {‚Ñ¨ : Type u} [Category.{v} ‚Ñ¨] \n    [LocallySmall.{w} ‚Ñ¨] [HasLimitsOfSize.{w, w} ‚Ñ¨] {S : Set ‚Ñ¨} [Small.{w} S] \n    (hS : IsCoseparating S) (h : ‚àÄ (A : ‚Ñ¨), ‚àÄ (s : Set (Subobject A)), ‚àÉ (f : Subobject A), \n    IsGLB s f) : HasInitial ‚Ñ¨ := by\n  sorry", "split": "test"}
{"name": "preservesFiniteLimits_tfae", "problem_id": "S_0085_preservesFiniteLimits_tfae", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Functor Limits ShortComplex\n\nvariable {C D : Type*} [Category C] [Category D]\nvariable [Abelian C] [Abelian D]\n\ntheorem preservesFiniteLimits_tfae\n    (F : C ‚•§ D) [F.Additive] : List.TFAE\n    [\n      ‚àÄ (S : ShortComplex C), S.ShortExact ‚Üí (S.map F).Exact ‚àß Mono (F.map S.f),\n      ‚àÄ (S : ShortComplex C), S.Exact ‚àß Mono S.f ‚Üí (S.map F).Exact ‚àß Mono (F.map S.f),\n      ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), PreservesLimit (parallelPair f 0) F,\n      PreservesFiniteLimits F\n    ] := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Functor Limits ShortComplex\n\nvariable {C D : Type*} [Category C] [Category D]\nvariable [Abelian C] [Abelian D]\n\ntheorem preservesFiniteLimits_tfae\n    (F : C ‚•§ D) [F.Additive] : List.TFAE\n    [\n      ‚àÄ (S : ShortComplex C), S.ShortExact ‚Üí (S.map F).Exact ‚àß Mono (F.map S.f),\n      ‚àÄ (S : ShortComplex C), S.Exact ‚àß Mono S.f ‚Üí (S.map F).Exact ‚àß Mono (F.map S.f),\n      ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), PreservesLimit (parallelPair f 0) F,\n      PreservesFiniteLimits F\n    ] := by\n  sorry", "split": "test"}
{"name": "has_left_adjoint_iff_continuous_and_initials", "problem_id": "S_0053_has_left_adjoint_iff_continuous_and_initials", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {D : Type u} [Category.{v} D] [HasLimits D] [LocallySmall.{v} D]\nvariable {C : Type u} [Category.{v} C]\nvariable (G : D ‚•§ C)\n\ntheorem has_left_adjoint_iff_continuous_and_initials :\n    G.IsRightAdjoint ‚Üî PreservesLimits G ‚àß ‚àÄ (c : C), HasInitial (StructuredArrow c G) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {D : Type u} [Category.{v} D] [HasLimits D] [LocallySmall.{v} D]\nvariable {C : Type u} [Category.{v} C]\nvariable (G : D ‚•§ C)\n\ntheorem has_left_adjoint_iff_continuous_and_initials :\n    G.IsRightAdjoint ‚Üî PreservesLimits G ‚àß ‚àÄ (c : C), HasInitial (StructuredArrow c G) := by\n  sorry", "split": "test"}
{"name": "hasColimits_iff_hasCoprod_of_separator", "problem_id": "S_0065_hasColimits_iff_hasCoprod_of_separator", "informal_prefix": "", "formal_statement": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C]\n\ntheorem hasColimits_iff_hasCoprod_of_separator\n    [HasLimits C]\n    [WellPowered C]\n    [WellPowered C·µí·µñ]\n    (S : C) (hS : IsSeparator S) :\n    HasColimits C ‚Üî ‚àÄ (I : Type v), HasColimit (Discrete.functor (fun (_ : I) => S)) := by\n  sorry", "lean4_code": "import Mathlib\n\nopen CategoryTheory Limits\n\nvariable {C : Type u} [Category.{v} C]\n\ntheorem hasColimits_iff_hasCoprod_of_separator\n    [HasLimits C]\n    [WellPowered C]\n    [WellPowered C·µí·µñ]\n    (S : C) (hS : IsSeparator S) :\n    HasColimits C ‚Üî ‚àÄ (I : Type v), HasColimit (Discrete.functor (fun (_ : I) => S)) := by\n  sorry", "split": "test"}
{"name": "compactSpace_iff_finitelyPresented_top", "problem_id": "S_0058_compactSpace_iff_finitelyPresented_top", "informal_prefix": "", "formal_statement": "theorem compactSpace_iff_finitelyPresented_top :\n    CompactSpace X ‚Üî IsFinitelyPresentable (C := Op X) (‚ä§ : Op X) := by\n  sorry\n\nend CAT_statement_S_0058", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ntheorem compactSpace_iff_finitelyPresented_top :\n    CompactSpace X ‚Üî IsFinitelyPresentable (C := Op X) (‚ä§ : Op X) := by\n  sorry\n\nend CAT_statement_S_0058", "split": "test"}
{"name": "functor_involution", "problem_id": "S_0010_functor_involution", "informal_prefix": "", "formal_statement": "def functor_involution : Grp.{u} ‚•§ Type u where\n  obj := fun G => { g : G.carrier |  g * g = 1 }\n  map := fun {G H} f x => ‚ü®f.hom x.val, by\n    refine Set.mem_setOf.mpr ?_\n    rcases x with ‚ü®g, hg‚ü©\n    simp only [Set.mem_setOf_eq] at hg\n    rw [‚Üê f.hom.map_mul, hg]\n    simp only [map_one]\n    ‚ü©", "lean4_code": "import Mathlib\nopen CategoryTheory\n\ndef functor_involution : Grp.{u} ‚•§ Type u where\n  obj := fun G => { g : G.carrier |  g * g = 1 }\n  map := fun {G H} f x => ‚ü®f.hom x.val, by\n    refine Set.mem_setOf.mpr ?_\n    rcases x with ‚ü®g, hg‚ü©\n    simp only [Set.mem_setOf_eq] at hg\n    rw [‚Üê f.hom.map_mul, hg]\n    simp only [map_one]\n    ‚ü©", "split": "test"}
